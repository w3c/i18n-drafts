<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<title>Перехід на Unicode</title>
<meta name="description" content="Ця W3C I18n стаття дає рекомендації з переходу програмного забезпечення і даних в Unicode. Вона охоплює планування переходу, та проектування і примінення програмного забезпечення Unicode." />
<script type="text/javascript">
var f = { }

// AUTHORS should fill in these assignments:
f.directory = 'articles/unicode-migration'+'/'; // the path to this file, not including /International or the file name
f.filename = 'index'; // the file name WITHOUT extensions
f.authors = 'Norbert Lindenberg, Yahoo!; Editor: Addison Phillips, Yahoo!'; // author(s) and affiliations
f.previousauthors = ''; // as above
f.modifiers = ''; // people making substantive changes, and their affiliation
f.searchString = 'article-unicode-migration'; // blog search string - usually the filename without extensions
f.firstPubDate = '2008-04-11'; // date of the first publication of the document (after review)
f.lastSubstUpdate = { date:'2008-04-11', time:'10:19'}  // date and time of latest substantive changes to this document
f.status = 'published';  // should be one of draft, review, published, notreviewed or obsolete
f.path = '../../' // what you need to prepend to a URL to get to the /International directory 

// AUTHORS AND TRANSLATORS should fill in these assignments:
f.thisVersion = { date:'2016-01-31', time:'06:01'} // date and time of latest edits to this document/translation
f.contributors = ''; // people providing useful contributions or feedback during review or at other times
// also make sure that the lang attribute on the html tag is correct!

// TRANSLATORS should fill in these assignments:
f.translators = 'Alexandr Shlapak (Александр Шлапак)'; // translator(s) and their affiliation - a elements allowed, but use double quotes for attributes

f.breadcrumb = 'characters';

f.additionalLinks = ''
</script>
<script type="text/javascript" src="index-data/translations.js"> </script>
<script type="text/javascript" src="../../javascript/doc-structure/article-dt.js"> </script>
<script type="text/javascript" src="../../javascript/boilerplate-text/boilerplate-uk.js"></script><!--TRANSLATORS must change -en to the subtag for their language!-->
<script type="text/javascript" src="../../javascript/doc-structure/article.js"> </script>
<script type="text/javascript" src="../../javascript/articletoc-html5.js"></script>
<link rel="stylesheet" href="../../style/article-2016.css" type="text/css" />
<!-- remove the following local css declaration if there is nothing to add -->
<link rel="stylesheet" href="filename-data/local.css" type="text/css" />
<link rel="copyright" href="#copyright"/>
<!--[if lt IE 9]><script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>

<body>
<header>
  <nav id="mainNavigation"></nav><script>document.getElementById('mainNavigation').innerHTML = mainNavigation</script>
  
  <h1>Перехід на Unicode</h1>
</header>


<section>
<div id="audience">
  <p><span id="intendedAudience" class="leadin">Intended audience:</span> 
    Веб-розробники, програмісти, адміністратори
    сайтів, та інші бажаючі перевести Веб сайт або Веб контент
    із застарілого (non-Unicode) кодування символів на Unicode. </p>
  <div id="updateInfo"></div><script>document.getElementById('updateInfo').innerHTML = g.updated</script> 
</div>

<p>Ця стаття дає рекомендації з переходу програмного забезпечення і даних в
  Unicode. Вона охоплює планування переходу, та проектування і примінення
  програмного забезпечення Unicode. Передбачається загальне уявлення про Unicode та принципи
  кодування символів. Деякі джерела інформації про це
  включають в себе: </p>
<ul>
  <li><a href="http://www.unicode.org/">Консорціум Unicode</a></li>
  <li><a href="http://www.w3.org/TR/CharMod">W3C Модель Символа</a></li>
  <li><a
    href="http://www.inter-locale.com/whitepaper/IUC-Intro-to-I18N-Tutorial.pdf">Посібник
    Інтернаціоналізації</a></li>
</ul>
</section>


<section>
  <h2 id="why"><a href="#why">Навіщо переходити на Unicode?</a></h2>
  <p>Є кілька причин для прийняття Unicode:</p>
  <ul>
    <li>Щоб обробити текст необхідно його розуміти, тому
      процес обробки залежить від кодування символів. Unicode забезпечує міцну основу
      для обробки тексту з усього світу, тоді як інші кодування вимагають
      окремих реалізацій для кожного кодування і кожне з них підтримує тільки обмежений набір
      мов. Відповідно використання Unicode також полегшує
      розподіл програмним забезпеченням для обробки тексту по всьому світу.</li>
    <li>Деякі програми підтримують зв'язок та співробітництво
      між користувачами, які проживають в різних частинах світу і використовують різні
      мови. Unicode - стандарт, який всім в світі, надає зв'язок  
      без обмежень, що накладаються мовою, якою спілкується користувач або регіоном, в якому 
      живуть користувачі. </li>
    <li>Оскільки багато мов не підтримуються, кодуваннями символів 
      відмінними від Unicode, то інколи користувачі представляють створений ними контент (такий
      як form data) у кодуваннях, відмінних від підтримуваних (наприклад,
      шляхом зміни кодування браузера). Це перешкоджає програмі
      правильно обробляти текст, наприклад, при його пошуку в 
      базі даних, або при виборі реклами для розміщення за ним.</li>
    <li>Багато Веб-сайтів або програмних помилок пов'язані з кодуваннями
      символів, тому що різні сайти або локалізації одного і того ж  
      сайту використовують різні кодування символів, і кодування текстових даних
      в багатьох місцях неправильне. </li>
  </ul>
  <p>Зверніть увагу, що простою зміною кодування символів ваших сторінок на Unicode
    ви не усуните всіх проблем із кодуванням символів. Насправді, під час
    переходу існує значно підвищений ризик таких помилок, тому що
    існуючі дані повинні бути перетворені в Unicode, а поточне кодування не
    завжди відоме. Цей документ містить поради, як мінімізувати цей ризик і
    як забезпечити механізми виправлення проблем перекодування.</p>
</section>
<section>
  <h2 id="planning"><a href="#planning">Планування переходу</a></h2>
  <p>Для можливості переходу на Unicode, ви повинні розуміти, використання
    кодувань символів у ваших поточних настройках і прийняти рішення про внутрішнє і
    зовнішнє використання кодувань символів для дизайну основаного на Unicode. Вам також
    потрібно знати стан Unicode підтримки в програмних компонентах, на яку ви можете покластися
    і в разі необхідності, спланувати перехід для цих компонентів. Це дозволяє вам, 
    планувати оновлення вашого програмного забезпечення, що повинно базуватися на основі Unicode та
    перетворення існуючих даних в Unicode кодування.</p>
  <p>Проект переходу на Unicode може бути також хорошим, щоб поліпшити
    інтернаціоналізацію в цілому. Зокрема, необхідно розглянути питання чи можете
    ви використовувати багатомовні можливості Unicode, щоб подолати 
    непотрібні бар'єри між різними аудиторіями, культурами чи мовами.
    Особливо для сайтів або програм, які дозволяють спілкування між користувачами
    і, таким чином приймати або передавати контент, що створений користувачами, є сенс створити
    один сайт із загальним багатомовним контентом не дивлячись на
    кілька локалізованих користувальницьких інтерфейсів.</p>
</section>
<section>
  <h2 id="understanding"><a href="#understanding">Розуміння поточного використання
    кодувань символів</a></h2>
  <p>Для початку, ви повинні добре розуміти як кодування символів використовуються
    у вашому програмному забезпеченні. Визначати компоненти
    програмного забезпечення і вмістилища даних: передня частина, задня частина, вмістилище, APIs(прикладні програмні інтерфейси), веб
    інтерфейси, і так далі, і з'ясувати їх використання в кодуваннях:</p>
  <ul>
    <li>Які компоненти вже основані на Unicode? Яке кодування Unicode
      використовується (UTF-8 чи UTF-16)? Які компоненти використовують застарілі(тобто відмінні
      від Unicode) кодування? </li>
    <li>Які потоки даних між компонентами, і які кодування
      використовуються в кожному випадку?</li>
    <li>Які кодування визначені для інтерфейсів між
      компонентами?</li>
    <li>Які кодування, визначені для зовнішніх інтерфейсів
      програмного забезпечення?</li>
    <li>Де відбувається перекодування?</li>
    <li>Чи чітко розділені одиниці тексту, які використовують різні кодування, і
      чи кодування зазначені в кожній точці, або чи існують можливості  
      для збереження чи обробки тексту в різних або невідомих кодуваннях?</li>
  </ul>
  <p>Останнє питання може здатися дивним, але воно особливо важливе. Відсутність
    достовірної інформації про кодування символів, яке використовується для тексту,
    який надходить ззовні сайту (такого, як канали контенту або дані введені користувачем) або,
    або, той, що вже у ваших колекціях даних є спільною проблемою та потребує
    особливої уваги. (Насправді, вам потрібно звернути увагу на ці речі,
    навіть якщо ви не перетворюєте дані в Unicode.) Існують різні випадки, коли 
    може відбутися ця відсутність правильної інформації:</p>
  <ul>
    <li>Дані із зовні можуть взагалі не визначити кодування символів. 
      Це дуже поширена проблема для електронної пошти, веб-сторінок, або каналів даних.</li>
    <li>Дані із зовні можуть не правильно визначити кодування символів.
      Це також спільна проблема для електронної пошти і веб-сторінок.</li>
    <li>Веб-додатки могли присвоїти кодування символів для форми 
      подання, але користувачі насправді змінили кодування в браузері.
      Користувачі часто це роблять, коли кодування, яке використовується веб-додатком
      не підтримує мову користувача, наприклад, додаток підтримує тільки
      ISO 8859-1, а користувач хоче використовувати нелатинські скриптові мови, такі
      як Грецька, Російська, Хінді, Китайська, і так далі.</li>
    <li>Кодування було відоме в певний момент, але потім ця інформація
      загубилась. Це звичайна ситуація з log files (файлами журналу) - веб-додаток
      можливо, не знав (або принаймні правильно гадав) кодування символів, яке
      використовується для HTTP запиту, але сам запит і, отже, запис
      журналу не містять цю інформацію.</li>
    <li>Дані пропускали через інтерфейс в одному кодуванні, де
      інтерфейс насправді вимагає інше кодування. Прикладом може служити
      зберігання інформації про користувача закодованої за допомогою UTF-8 в базі даних
      ISO 8859-1.</li>
  </ul>
  <p>Щоб справитися з такими ситуаціями, зазвичай використовується виявлення кодування
    символів. Спроби виявлення кодування використовуються в послідовності байтів 
    основаній на характеристиках самої послідовності байтів. У більшості випадків
    це статистичний процес, який для хорошої роботи потребує довгих вхідних послідовностей байтів,
    хоча ви зможете поліпшити її точність при використанні іншої доступної для
    вашого додатку інформації. Через високу ймовірність помилок, для людей часто
    необхідно передбачати способи їх виявлення і виправлення. Це 
    потребує доступності оригінальної послідовності байтів для подальшої реконверсії.
    Приклади бібліотек визначення кодування включають в себе:</p>
  <ul>
    <li><a
  href="http://www.mozilla.org/projects/intl/chardet.html">Mozilla</a></li>
    <li><a
  href="http://icu-project.org/userguide/charsetDetection.html">ICU</a></li>
  </ul>
</section>
<section>
  <h2 id="checking"><a href="#checking">Перевірка підвалин</a></h2>
  <p>Реалізація програмного забезпечення часто залежить від іншого програмного забезпечення:</p>
  <ul>
    <li>мови програмування та пов'язані з ними бібліотеки,</li>
    <li>двигун бази даних,</li>
    <li>програмні платформи або бібліотеки на яких базується ваше програмне забезпечення,</li>
    <li>інші сайти або програми з якими взаємодіє ваше програмне забезпечення,</li>
    <li>сторонні бібліотеки, </li>
    <li>інструменти, які ви використовуєте для створення, тестування та розгортання програмного забезпечення.</li>
  </ul>
  <p>Ви повинні перевірити, чи програмне забезпечення від якого ви залежите підтримує Unicode, чи
    принаймні не ставить вам перешкод у його прийнятті. Це звичайно буде 
    необхідним для поновлення на нові версії базових платформ, і в деяких 
    випадках потрібно буде перейти із застарілих платформ на 
    нові.</p>
</section>
<section>
  <h2 id="internal"><a href="#internal">Вибрати кодування символів для 
    внутрішнього використання</a></h2>
  <p>Unicode пропонує три форми кодування: UTF-8, UTF-16, та UTF-32. 
    Зазвичай для переміщення по мережі або для збереження у файлах кодування UTF-8 працює
    найкраще тому, що воно сумісне з ASCII, тоді як схожі на ASCII байти, що
    містяться в UTF-16 та UTF-32 тексті - це проблема для деяких мережевих
    пристроїв або інструментів обробки файлів. Для обробки в пам'яті, всі три 
    форми кодування можуть бути корисними, і найкращий вибір часто залежить від
    програмних платформ і бібліотек, які ви використовуєте: Java, JavaScript, ICU, і більшість
    Windows APIs (прикладні програмні інтерфейси) базуються на основі UTF-16, в той час як Unix системи, як правило, віддають перевагу UTF-8.
    Розмір даних, що зберігаються рідко стає фактором при прийнятті рішення між UTF-8 і UTF-16, оскільки
    обидва можуть мати кращий розмір профілю, в залежності від поєднання розмітки і
    Європейських чи Азіатських мов. UTF-32 є неефективним для зберігання і, отже, 
    рідко використовується з цією метою, але воно дуже зручне для обробки, і
    деякі бібліотеки, такі як Java та ICU, забезпечили рядок доступу та обробки 
    API (прикладні програмні інтерфейси) з точки зору UTF-32 code points (місця коду). Перетворення між трьома формами кодування 
    швидке і безпечне, так що використання різних форм кодування в різних компонентах
    великих програмних систем цілком реальне і поширене.</p>
  <p>Із впевненістю можна сказати, що зберігання тексту, кодування якого не відоме є
    виключенням із єдиного правила Unicode. Такий текст часто потрібно інтерпретувати 
    використовуючи технологію розпізнавання кодування символів. І виявлення кодування символів не 
    надійний процес. Таким чином, ви повинні поблизу тримати оригінальні байти (поряд з
    виявленим кодуванням символів), так щоб текст можна було повторно перетворити, коли
    людина змінить кодування.</p>
</section>
<section>
  <h2 id="externalif"><a href="#externalif">Вибрати кодування символів для 
    зовнішніх інтерфейсів</a></h2>
  <p>Для взаємодії вашої програми із зовнішнім світом, UTF-8 потрібно
    використовувати скрізь, де це можливо. Однак є ситуації, коли ви не можете контролювати
    кодування або потребуєте взаємодії з системами, які не підтримують UTF-8.
    Ось рекомендації для поширених випадків:</p>
  <ul>
    <li>
      <p><strong class="leadin">Електронна пошта:</strong> Ви повинні приймати вхідні
        листи в будь-якому кодуванні, що використовує ваша електронна пошта. Для вихідної пошти, вам, можливо, доведеться
        взяти до уваги, що багато старих програми електронної пошти не підтримують
        UTF-8. В даний час, вихідна пошта повинна бути перетворена 
        в застаріле кодування, яке може відобразити її весь контент; UTF-8 треба
        використовувати лише тоді, коли не можна знайти таке застаріле кодування. Кодування
        вихідної пошти повинне бути вказане. Які вихідні кодування
        використовувати залежить від потреб вашої програми.</p>
    </li>
    <li>
      <p><strong class="leadin">URIs та POST
        дані:</strong> Вони використовуються в кількох різних контекстах: форма
        подання, веб-сервіси, або URL-адреси, введені безпосередньо в веб-браузері.
        Для форми подання, HTML форма повинна бути розроблена з можливістю виявлення
        кодування символів, навіть якщо користувач змінить його в браузері. (Ви можете
        використовувати JavaScript або спеціальні значення полів, щоб визначити, чи 
        змінив користувач кодування: можливо, ви повинні м'яко нагадувати користувачеві не робити 
        цього?)</p>
    </li>
    <li>
      <p><strong class="leadin">Веб
        служби:</strong> Веб служби (Особливо Веб служби основані на REST (передача стану подання))
        повинні визначати використання UTF-8 і відкидати запити, які не дійсні для UTF-8.
        Для сторонніх веб сервісів, використовуйте UTF-8, якщо ця функція підтримується веб 
        сервісом та переконайтесь в правильній ідентифікації використовуваного кодування.
        Для URIs (Уніфікований Ідентифікатор Ресурсів) кодування вводиться безпосередньо у веб браузері (наприклад, маркетингові URIs), 
        інші кодування можливо потребують підтримки.</p>
    </li>
    <li>
      <p><strong class="leadin">HTML:</strong> При подачі сторінок на настільні браузери, використовуйте кодування UTF-8; його підтримка зараз
        є майже універсальною. Мобільні браузери не завжди підтримують UTF-8, так що ви можете
        використовувати застарілі кодування в залежності від цільового пристрою.
        Кодування, яке використовується повинне бути призначене з використанням HTTP: заголовок <code
    class="kw" translate="no">Content-Type</code>, HTML <code
    class="kw" translate="no">meta</code> тег, або (переважно) обидва. Якщо ви не можете контролювати
        конфігурацію вашого сервера, на рівні файлів або запитів або не можете налаштувати
        його для подання UTF-8 в якості кодування, тоді переконайтесь, що він взагалі
        не відправляє кодування: користувацькі додатки звертають увагу на це кодування 
        перед тим як щось призначити в meta тег. Правильний HTML <code
    class="kw" translate="no">meta</code> тег: </p>
      <p
   ><code>&lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8"&gt;</code></p>
      <p>Як встановити HTTP <code
    class="kw" translate="no">Content-Type</code> заголовок залежить від вашого середовища
        виконання. Наприклад, в PHP, ви повинні використовувати: </p>
      <p
   ><code>&lt;?php header("Content-type: text/html; charset=UTF-8"); ?&gt;</code>. </p>
      <p>Дивіться докладнішу інформацію на сторінці <a 
    href="http://www.w3.org/International/O-HTTP-charset">установка
        content-type</a>.</p>
      <p>Якщо ви взяли контент за межами вашого сайту (наприклад, 
        веб-павук пошукової системи або зовнішній HTML), то вам доведеться 
        мати справу з будь-яким кодуванням. У деяких випадка
        це означає прийняття та обробку кодування, що використовується. Якщо ви включите
        той матеріал у свої власні сторінки, то ви повинні будете зробити кодування 
        відповідним до вашої сторінки (або покласти його в тег iframe, де він може використовувати своє 
        оригінальне кодування).</p>
    </li>
    <li>
      <p><strong
    class="leadin">XML:</strong>Вихідні XML завжди повинні бути закодовані в
        UTF-8; <a href="http://www.w3.org/TR/REC-xml/#charencoding">XML
        специфікація</a> потребує, щоб кожен XML аналізатор розумів це. Для джерел даних XML,
        вкажіть використання UTF-8. В інших випадках, XML файли закодовані в
        інших кодуваннях повинні бути прийняті до тих пір, поки вони дійсні. Зверніть увагу, що HTTP Content-Type text/XML за замовчуванням US-ASCII (із цього приводу, як правило, віддається перевага application/xml+*) і вам все одно потрібно вказати charset (набір символів), якщо ви використовуєте text/xml Content-Type.</p>
    </li>
    <li>
      <p><strong class="leadin">JSON:</strong> Вихідні дані JSON завжди повинні бути закодовані в UTF-8, і бажано в
        ASCII із екранованими символами \u для всіх відмінних від ASCII символів. Для вхідних даних,
        може бути також розглянута підтримка UTF-16 і UTF-32. <a
    href="http://www.ietf.org/rfc/rfc4627.txt">Специфікація JSON</a> не
        дозволяє будь-яких інших кодувань.</p>
    </li>
    <li>
      <p><strong class="leadin">Серіалізована
        PHP:</strong> Цей формат даних, слід уникати, оскільки він не
        дозволяє специфікацію кодування, що використовується, і тому, ймовірно, може
        привести до пошкодження даних відмінного від ASCII тексту. JSON є гарною альтернативою.
        Якщо ви абсолютно не можете уникнути серіалізованої PHP, то вкажіть кодування UTF-8 і використовуйте його.</p>
    </li>
    <li>
      <p><strong class="leadin">Інші канали 
        даних:</strong> Там де ви можете впливати на кодування вхідних 
        каналів даних, воно повинно бути UTF-8, або принаймні добре визначеним. Там можуть 
        бути випадки, коли ви хочете використовувати канали даних, які ви не можете контролювати, в
        такому випадку вам доведеться використовувати все, що ви отримаєте.</p>
    </li>
  </ul>
  <p>Як правило, вхідний текст повинен бути перетворений в кодування Unicode якомога 
    швидше, а вихідний текст, якщо він повинен бути відправлений у кодуванні відмінному від 
    Unicode, треба перетворити з Unicode кодування в те інше кодування якомога пізніше.
    Однак, якщо кодування вхідного тексту достовірно не можна 
    визначити, тоді оригінальний текст повинен бути збережений разом з інформацією про
    ймовірне кодування. Це дозволяє коригувати свої дії, якщо виявиться що
    було обране неправильне кодування.</p>
</section>
<section>
  <h2 id="roadmap"><a href="#roadmap">Створення плану</a></h2>
  <p>Для дуже простих сайтів або програм можна змінити
    все програмне забезпечення, так щоб воно грунтувалося на основі Unicode, перевести всі дані в Unicode
    кодування, і в одну мить перемикати із попередньої версії на Unicode  
    версію. Але багато сайтів або програм пропонують зовнішні інтерфейси,
    мають великі тіла коду і накопичили величезні масиви даних, тому їх
    перетворення - великий проект з декількома залежностями, який повинен бути
    ретельно спланований. Ось розбивка на ймовірні підпроекти:</p>
  <ul>
    <li>Вкажіть кодування, що використовується в існуючих APIs (прикладні програмні інтерфейси). Оскільки все більше компонентів
      збираються використовувати Unicode кодування, то важливо знати, які
      компоненти цього ще не зробили для того, щоб уникнути пошкодження даних.</li>
    <li>Запровадити основані на Unicode версії зовнішніх інтерфейсів
      від яких залежить інше програмне забезпечення. Це має бути першим кроком для того, щоб
      дозволити перехід залежного програмного забезпечення. На цьому етапі кожен
      зовнішній інтерфейс (API(Прикладний програмний інтерфейс), веб сервіс, потік даних), який базується на основі застарілих
      кодувань дублюється з паралельним основаним на Unicode інтерфейсом. Для багатьох 
      інтерфейсів, первісний варіант нового інтерфейсу просто перетворює
      вхідний текст з Unicode в застаріле кодування, яке досі використовуються,
      викликає старий інтерфейс, і перетворює вихідний текст із застарілого  
      кодування в Unicode. В деяких випадках, новий інтерфейс буде достатньо
      відрізняється від старого: Наприклад, де старий інтерфейс складається
      із прямого доступу до загальних даних, новий інтерфейс повинен бути API
      (так, інкапсуляція даних є гарною ідеєю). Використання застарілих кодувань в
      базовій реалізації означає, що підтримується тільки підмножина набору символів 
      Unicode - це обмеження повинне бути задокументовано, а 
      потім видалене за допомогою наступних кроків.</li>
    <li>Заохочуйте власників інших продуктів, які мають доступ до ваших 
      баз даних перейти на новий API(Прикладний програмний інтерфейс). Вам буде краще щоб це
      почалося якомога раніше тому, що ви не зможете перетворити вашу базу данних в Unicode доки
      інші мають доступ до неї використовуючи застарілі кодування.</li>
    <li>Введіть рівень абстракції до приватних баз даних продукту, що  
      оснований на Unicode. Подібно до кроку вище, це дозволяє
      перетворення реалізації вашого продукту, і дозволяє йти вперед без 
      очікування перетворення баз даних.</li>
    <li>Перетворення реалізації вашого продукту на Unicode. Частиною
      цього кроку, може бути зміна вашого зовнішнього інтерфейсу таким чином, що тепер
      версії основані на Unicode працюватимуть безпосередньо із реалізацією, в той час
      як версії, які основані на застарілих кодуваннях перетворюватимуться на Unicode та із Unicode. Для великих
      сайтів або програми, цей крок може початися із основаних на Unicode
      внутрішніх інтерфейсів між підсистемами, подібне до того, що ви зробили для
      зовнішніх інтерфейсів вище, так щоб підсистеми можна було конвертувати
      самостійно.</li>
    <li>
      <p>Перетворення ваших баз даних та/або сховищ даних
        в Unicode. Якщо бази даних були доступні іншим продуктам,
        можливо вам доведеться чекати, поки ті продукти перейдуть на APIs, які
        були представлені в першому кроці. Розділ <a
    href="#migratingdata">Передача даних</a> містить більше інформації про цей
        крок.</p>
    </li>
    <li>Видаліть інтерфейси, засновані на застарілих кодуваннях. Це
      буде заключний етап вашого переходу, і, в залежності від того, хто покладається на
      ці інтерфейси, можливо, доведеться чекати довго.</li>
  </ul>
  <p>Деякі з цих підпроектів можуть виконуватися паралельно або в іншому 
    порядку, залежно від конкретної ситуації вашого продукту. Наприклад, 
    перехід реалізації вашого продукту може затриматися в
    залежності від інших програмних компонентів, які ще досі не достатньо
    просунулися в процесі їх переходу. З іншого боку бази даних SQL можна
    перетворити в Unicode набагато раніше, тому що клієнтський компонент програмного забезпечення  
    бази даних ізолює клієнтів від кодування, що використовується в базі даних і
    здійснює перетворення кодування символів у разі потреби. Перетворення баз даних
    на ранній стадії має свої переваги: воно спрощує тестування, тому що базу даних
    можна протестувати незалежно від програмного забезпечення, що її використовує, під час тестування програмного забезпечення
    більш високого рівня як правило, необхідна база даних, і використовуючи застарілі кодування 
    ви зможете об'єднати декілька окремих баз даних в одну багатомовну
    базу даних.</p>
</section>
<section>
  <h2 id="designing"><a href="#designing">Проектування для Unicode</a></h2>
  <section>
    <h3 id="encodingspecs"><a href="#encodingspecs">Специфікації кодування 
      символів</a></h3>
    <p>Послідовність байтів може бути правильно інтерпретована як текст тільки,  
      якщо кодування символів відоме. Багато додатків написані так, що вони просто
      переміщають послідовності байтів, не називаючи кодування символів. Як вже вище було сказано
      це завжди викликає проблеми. Але це трапляється у випадках,
      коли всі користувачі спілкуються однією мовою або готові адаптуватися до деякого
      неправильно зробленого контенту на сторінці. У процесі переходу на
      Unicode, кожна мова буде оброблятися як мінімум в двох кодуваннях,
      застаріле кодування для мови та UTF-8, так що зазначення кодування
      для кожної послідовності байтів буде мати вирішальне значення для того, щоб 
      уникнути лавини помилок пошкодження даних.</p>
    <p>Кодування символів можна задати різними шляхами:</p>
    <ul>
      <li>
        <p>У специфікації формату: специфікація для
          формату даних може вказати кодування символів або напряму, або 
          вказати простий детермінований механізм для визначення кодування символів 
          дивлячись на початок послідовності байтів. Прикладами є
          специфікація <a
    href="http://java.sun.com/javase/6/docs/api/java/lang/String.html">Java
          String class</a>, яка визначає UTF-16, та <a
    href="http://www.ietf.org/rfc/rfc4627.txt">специфікація JSON</a>, яка
          приписує використання Unicode кодувань і як їх 
          розрізняти.</p>
      </li>
      <li>
        <p>У рамках послідовності байтів: Специфікація
          для формату даних може передбачати механізм для вказівки 
          кодування символів як частини послідовності байтів. XML
          специфікація робить це в елегантний спосіб використовуючи <a 
    href="http://www.w3.org/TR/2006/REC-xml-20060816/#charencoding">призначення
          кодування</a>, HTML специфікація робить це в менш елегантний спосіб використовуючи <code class="kw" translate="no"><a
    href="http://www.w3.org/TR/html401/charset.html#h-5.2.2">meta</a></code> тег. Для форматів даних, які дозволяють таку специфікацію, дані можуть містити
          специфікацію кодування, якщо тільки послідовність байтів в кодуванні - UTF-8 та
          специфікація забезпечує правильне виявлення UTF-8 (як для XML). Для HTML
          файлів <code class="kw" translate="no">meta</code> тег вказує content type
          та кодування символів повинно бути першою підкатегорією елементу <code
    class="kw" translate="no">head</code> , і перед ним не мають стояти символи відмінні від
          ASCII.</p>
      </li>
      <li>
        <p>У даних, що є зовнішніми по відношенню до послідовності байтів:
          У багатьох випадках, вмістилище послідовності байтів забезпечує специфікацію 
          кодування. Кілька прикладів будуть включати в себе HTTP або MIME, де поле <code class="kw" translate="no"><a
    href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type</a></code> заголовок може вказати кодування і бази даних, де 
          кодування вказане як частина схеми або конфігурації 
          бази даних. Знову ж таки, де такі можливості існують, текстові дані повинні
          використовувати їх. У деяких випадках, таких як відправка HTML через HTTP
          зовнішня специфікація кодування може дублювати те, що є частиною послідовності  
          байтів - це добре, тому що веб браузери віддають перевагу  
          заголовку HTTP, в той час як <code class="kw" translate="no">meta</code> тег - єдина
          специфікація, яка зберігається при збереженні файлу на диск.</p>
      </li>
      <li>
        <p>У специфікаціях інтерфейсу: Специфікації інтерфейсів,
          які приймають або повертають послідовності байтів без будь-яких специфікацій 
          кодування символів можуть (і повинні) вказувати використовуване 
          кодування символів. Специфікація може бути абсолютною або відносною по відношенню до 
          середовища установки. Наприклад, деякі бібліотеки надають функції, які 
          приймають або повертають рядки в UTF-8, в той час як інші приймають або повертають рядки 
          закодованими в деякі застарілі кодування.</p>
      </li>
      <li>
        <p>У контексті: кодування символів можна
          вивести із контексту в якому зустрічається послідовність байтів. 
          Наприклад, браузери звичайно відправляють дані форми в кодуванні символів,
          яке використовує сторінка, що містить цю форму. Це дуже слабка форма
          специфікації тому що послідовність байтів часто передається з 
          контексту, наприклад, в log файли, де кодування вже не можна
          змінити. Крім того, користувачі іноді міняють кодування браузера так, що
          кодування даних форми, що повертається не буде відповідати кодуванню 
          сторінки, створеної веб-додатком. Використання UTF-8 є одним із способів
          звести до мінімума шкоду від цієї слабкої форми специфікації  
          кодування тому що усуває необхідність користувачам змінювати
          кодування браузера і тому для UTF-8 виявлення кодування символів працює краще 
          ніж для більшості інших кодувань. </p>
      </li>
      <li>За зовнішньою угодою: Коли нічого з вищепереліченого не застосовується,
        таке як звичайні текстові файли, то потрібно зробити зовнішню угода про
        кодування. Така угода могла б, наприклад, бути частиною ліцензійної 
        угоди для стрічки контенту. Перші чотири механізми кращі, ніж 
        два останні і їм слід віддавати перевагу скрізь, де це можливо. Краще  
        використати будь-який із них, ніж взагалі не вказувати кодування.</li>
    </ul>
  </section>
  <section>
    <h3 id="encodingnames"><a href="#encodingnames">Назви кодувань 
      символів</a></h3>
    <p>Існує стандарт для назв кодування символів в інтернеті, <a
href="http://www.ietf.org/rfc/rfc2978.txt">RFC 2978</a>, та пов'язаний <a
href="http://www.iana.org/assignments/character-sets">реєстр IANA 
      charset</a>. Однак фактичне використання часто відрізняється. Багато кодувань приходять в
      різних варіантах або мають сестринські кодування, які підтримують розширені набори символів, та
      різне програмне забезпечення, яке часто використовує різні назви для одного і того ж кодування або
      ту саму назву для різних кодувань. Наприклад, назва ISO-8859-1 часто використовується для опису даних, які насправді використовують кодування windows-1252. Це останнє кодування (Microsoft Windows code page 1252) дуже схоже на кодування ISO 8859-1, але призначає графічні символи до діапазону байтів між 0x80 та 0x9F. Багато веб-додатків (таких як браузери, пошукові системи, і т.д.) відносяться до контенту відміченого, як ISO 8859-1, як до такого, що використовує кодування windows-1252 тому, що для всіх практичних цілей, windows-1252 є &quot;розширенням&quot; ISO 8859-1. Інші програми, такі як перетворювачі кодування (наприклад, iconv або ICU) досить буквальні і ви повинні вказати правильну назву кодування, щоб отримати правильні результати.</p>
  </section>
  <section>
    <h3 id="determination"><a href="#determination">Визначення кодування 
      символів</a></h3>
    <p>Всякий раз, коли послідовність байтів інтерпретується як текст і обробляється, її 
      кодування символів має бути відомим. У багатьох випадках визначення кодування
      символів настільки тривіальне, що про це навіть не задумуються - наприклад, коли 
      обробляється рядок у мові програмування, яка вказує, що рядки 
      закодованні в UTF-16. Однак в інших випадках, немає чіткої специфікації чи
      доступне кодування символів, або текст, приходить від джерела, якому не можна 
      повністю довіряти, щоб забезпечити правильну специфікацію. У таких випадках 
      більш складний процес, потребує визначення кодування символів і 
      пізніше потрібно включити виправлення зроблених помилок: </p>
    <ul>
      <li>Інтерпретувати будь-які доступні специфікації кодування символів. Якщо
        специфікація доступна і їй можна довіряти, то все готово.</li>
      <li>Якщо специфікація кодування символів доступна, але їй
        повністю не можна довіряти, то перевірте її. Перевірка доступна для кодувань,
        які накладають обмеження на дійсні послідовності байтів, такі як UTF-8, EUC-KR,
        ISO 2022-JP. Якщо текст перетворений на інше кодування для
        внутрішньої обробки, перевірка часто є просто побічним ефектом 
        перетворення, але якщо перетворення не потрібно, то необхідно зробити 
        перевірку. Якщо послідовність байтів неприпустима для зазначеного кодування вам
        необхідно відмовитися від вхідної інформації та зв'язатися із провайдером, щоб він надав правильну вхідну інформацію (у
        випадку XML, відмова необхідна відповідно до специфікації). Тим не менш, у
        випадках, коли у вас немає контролю над даними, переходьте до наступного
        кроку.</li>
      <li>Якщо специфікація кодування символів не доступна, або 
        не вдалося провести перевірку використовуйте виявлення кодування символів для визначення ймовірного
        кодування.</li>
      <li>Якщо кодування було визначене шляхом виявлення
        (а не за специфікацією і перевіркою), то тримайте неподалік оригінальну 
        послідовність байтів, для того щоб пізніше можна було знову перетворити його  
        на інше кодування символів. Забезпечте механізм користувальницького інтерфейсу, який дозволяє користувачам
        перевизначити задане або виявлене кодування символів і повторити 
        перетворення. Збережіть разом із послідовністю байтів кодування символів, що найчастіше  
        використовуються для послідовності байтів, особливо, якщо це було вибором 
        користувача, це допоможе уникнути непотрібного перероблення всіх вищезазначених кроків.</li>
    </ul>
  </section>
  <section>
    <h3 id="selection"><a href="#selection">Вибір та призначення кодування символів</a></h3>
    <p>При відправці тексту, вибір відповідного кодування символів повинен базуватися на основі формату даних та одержувача. Розділ <a href="#externalif">Прийняття Рішення про Використання Кодування Символів для Зовнішніх Інтерфейсів</a> обговорює використання кодування на основі форматів даних. У більшості випадків рекомендується Unicode кодування. Однак, є два основних винятки: </p>
    <ul>
      <li>
        <p><em>Електронна пошта</em>: Багато старих програми електронної пошти не підтримують UTF-8. В даний час, електронна пошта повинна перетворюватися в застаріле кодування, яке може представити весь її контент; UTF-8 слід використовувати тільки тоді, коли не можливо знайти таке застаріле кодування.</p>
      </li>
      <li>
        <p><em>Мобільні браузери</em>: Мобільні системи не завжди підтримують UTF-8. Тому можливо необхідно буде вибрати інші кодування на основі конкретного пристрою. </p>
      </li>
    </ul>
    <p>Незалежно від того, яке кодування використовується, кодування символів однозначно треба вказувати, використовуючи один з механізмів, описаних в розділі <a href="#encodingspecs">Специфікації Кодувань Символів</a>. </p>
  </section>
  <section>
    <h3 id="ceconversion"><a href="#ceconversion">Перетворення кодування символів</a></h3>
    <p>Перекодування потрібно завжди, коли текст очікується в одному кодуванні символів в одному місці та в іншому кодуванні символів у наступному місці. ICU та iconv - часто використовувані бібліотеки для перетворення кодування символів, однак, деякі платформи, такі як Java і Perl, надають свої бібліотеки перетворення.</p>
    <p>При використанні бібліотек, важливо використовувати правильні назви кодування для конкретної бібліотеки. Для більш детальної інформації дивіться розділ <a href="#encodingnames">Назви Кодування Символів</a>.</p>
    <p>Є деякі конкретні питання щодо перетворення, які можуть вплинути на певні
      продукти:</p>
    <ul>
      <li>Альтернативні відображення деяких символів: в деяких Східно-азіатських
        кодуваннях, деякі символів мають кілька тлумачень. Наприклад,
        значення 0x5C в Shift-JIS може бути витлумачено в іменах файлів як "\", але
        у фінансових даних як "¥". При відображенні Unicode, має бути прийняте
        рішення відображати або U+005C "\" або U+00A5 "¥". Загальний підхід - 
        відображати U+005C, який працює у файловій системі і який багато Японських
        шрифтів відображатимуть як "¥". Однак, якщо поведінка вашої програми
        може залежати від відображення (наприклад, вона аналізує значення валюти), ви маєте 
        вжити необхідних заходів, щоб контролювати результат. У випадоку приклада,
        ви могли б перед перетворенням відобразити 0x5C як код валюти "JPY" і
        потім, після перетворення "JPY" як U+00A5.</li>
      <li>
        <p>Символи приватного використання: Кілька
          кодувань символів, включаючи Unicode і більшість кодувань Східної Азії, 
          мають діапазони code point (місце коду), які зарезервовані для приватного використання або просто
          не визначені. Вони часто використовуються для символів конкретного або приватного  
          використання — <a href="http://en.wikipedia.org/wiki/Emoji">emoji</a> встановлена Японськими операторами мобільного зв'язку є прикладом. Стандартні перетворювачі
          символів не знають як відобразити такі символи. Для додатків, де
          підтримка символів приватного використання є критичною, щоб забезпечити правильне відображення вам краще 
          використовувати звичайні перетворювачі символів або використовувати обхідні шляхи, такі як numeric character
          references (числові посилання).</p>
      </li>
      <li>
        <p>Версії кодувань символів і 
          відображень: Багато кодувань символів змінювалися з плином часу, і тому
          співставте їх. Прикладом може служити відображення з <a
    href="http://en.wikipedia.org/wiki/HKSCS">HKSCS</a> в Unicode: Ранні
          версії HKSCS мали відображати числові символи в області приватного використання Unicode,
          бо Unicode не підтримував їх, але пізніше ці 
          символи додали до набору символів Unicode, і
          відображення із HKSCS були змінені, щоб відобразити нові додані символи. 
          Взагалі, ви повинні переконатися, що ви використовуєте останні версії
          перетворювачів символів.</p>
      </li>
    </ul>
  </section>
  <section>
    <h3 id="normalization"><a href="#normalization">Нормалізація</a></h3>
    <p>В Unicode деякі символи можна представити більш ніж в один спосіб.
      Unicode визначає кілька шляхів усунення цих відмінностей, коли вони
      не мають значення для обробки тексту. Для отримання додаткової інформації про Нормалізацію, дивіться <a
href="http://www.w3.org/TR/charmod-norm">CharMod-Norm</a>. </p>
    <p>Unicode не наказує, коли використовувати конкретну форму Unicode
      нормалізації. Тим не менш, цілий ряд процесів, працює краще, якщо текст нормований, в
      окремих процесах, які містять в собі порівняння тексту, таких як сортування, пошук та
      обробка regular expression (регулярний вислів). Деякі бібліотеки виконуючи ці процеси 
      пропонують нормалізацію в якості частини процесу; в іншому випадку, перш ніж використовувати 
      ці процеси ви повинні переконатися, що текст нормований. Як правило, нормалізаційна
      форма C (NFC) рекомендована для веб-додатків. Тим не менш, деякі процеси,
      такі як інтернаціоналізовані доменні імена, використовують інші нормалізаційні форми.</p>
    <p>Деякі мови потребують нормалізації перед обробкою, оскільки
      різні методи введення можуть генерувати різні послідовності codepoints (місце коду) 
      Unicode. В'єтнамська мова є яскравим прикладом, де в'єтнамська розкладка клавіатури
      починаючи із Windows 2000 і вище виробляє послідовності символів, які відрізняються від, тих
      що виробляє більшість В'єтнамського програмного забезпечення для введення даних. Аналогічні питання виникають
      у ряді Африканських мов, перша, що спадає на думку - 
      Йоруба.</p>
  </section>
  <section>
    <h3 id="textsize"><a href="#textsize">Питання щодо розміру текста</a></h3>
    <p>Зберігання тексту в Unicode часто займає більше місця, ніж збереження його в застарілих
      кодуваннях. Точне значення зайнятого простору залежить від мови і конкретного тексту. Простір для деяких поширених кодувань може бути:</p>
    <table>
      <tbody>
        <tr>
          <td><p><strong>Джерело Кодування</strong> </p></td>
          <td><p><strong>Мови</strong> </p></td>
          <td><p><strong>UTF-8</strong> </p></td>
          <td><p><strong>UTF-16</strong> </p></td>
        </tr>
        <tr>
          <td>ASCII </td>
          <td>Англійська, Малайська, ... </td>
          <td>0% </td>
          <td>100% </td>
        </tr>
        <tr>
          <td>ISO-8859-1</td>
          <td>Західноєвропейські </td>
          <td>10% </td>
          <td>100% </td>
        </tr>
        <tr>
          <td>ISO-8859-7, звичайний текст </td>
          <td>Грецька </td>
          <td>90% </td>
          <td>100% </td>
        </tr>
        <tr>
          <td>ISO-8859-7, 50% розмітка </td>
          <td>Грецька </td>
          <td>45% </td>
          <td>100% </td>
        </tr>
        <tr>
          <td>TIS-620, звичайний текст </td>
          <td>Тайська </td>
          <td>190% </td>
          <td>100% </td>
        </tr>
        <tr>
          <td>TIS-620, 50% розмітка </td>
          <td>Тайська </td>
          <td>95% </td>
          <td>100% </td>
        </tr>
        <tr>
          <td>EUC-KR, звичайний текст </td>
          <td>Корейська </td>
          <td>50% </td>
          <td>5% </td>
        </tr>
        <tr>
          <td>EUC-KR, 50% розмітка </td>
          <td>Корейська </td>
          <td>25% </td>
          <td>55% </td>
        </tr>
      </tbody>
    </table>
    <p>На макрорівні це насправді не має великого значення. В даний час пропускна 
      спроможність та вмістилище мережі зайняті відео, зображенням та звуковими файлами, а текст
      споживає тільки частку. Там може бути вплив на системи зберігання даних, що
      зберігають тільки текст. Якщо вас насправді бентежить розмір тексту, то його можна зменшити 
      використовуючи стиснення.</p>
    <p>Однак на мікрорівні, збільшення розміру вмістилища має ряд
      наслідків:</p>
    <ul>
      <li>Алгоритми, які були розроблені під допущення одного символу,
        одного байту, більше не працюють навіть для Європейських мов (вони ніколи не 
        працювали для Східно-азіатських мов). Їх потрібно змінити, щоб пристосувати
        мультибайтне відображення символів. Переконайтеся, що вся обробка 
        завжди працює з повними символами. Повний символ може зайняти 
        від одного до чотирьох байт в кодуванні UTF-8, і одну або дві одиниці 16-бітного коду
        в UTF-16. Для позицій символу, завжди використовуйте індекс
        first byte (першого байту) або code unit (елемент коду) символа.</li>
      <li>Зазвичай, специфікації будь-якої довжини треба переглянути для того, щоб
        переконатися, що вони базуватимуться на основі байтів, символів, UTF-16 
        code units (елементи коду), або гліфів. Кожна основа має сенс у деяких ситуаціях, але
        має бути ясно, яка з них застосовується. Використання основаного на символах визначення 
        гарантує достатньо місця, але може зайняти більше місця, ніж необхідно, 
        тому що кожен символ тепер потребує 4 байта. Використання
        основаного на байтах визначення дозволяє уникнути такого розміру, але може значно обмежити
        кількість символів. Найкращими, звичайно, є схеми, які виділяють
        достатньо місця для зберігання даного тексту. Інші додатки, що керують простором
        (наприклад, декілька "символів", які можуть відображатися у полі форми)
        можуть не мати можливості щось зробити з декількома логічними символами, а замість цього 
        необхідно підрахувати кількість одиниць візуального тексту (так звані графеми).</li>
      <li>Розмір тексту змінюється при кожному його перетворенні з одного
        кодування в інше. Немає фіксованих коефіцієнтів, які можна застосувати
        для оцінки розміру необхідного вмістилища, так що єдиний спосіб дізнатися це -
        насправді перетворити текст. Необхідно бути обережним, щоб уникнути скорочення. Якщо
        скорочення насправді необхідне, як і в деяких відображуваних контекстах, особливу увагу
        треба звернути на скорочення меж символа або графеми.</li>
    </ul>
  </section>
  <section>
    <h3 id="libraries"><a href="#libraries">Використання 
      бібліотек</a></h3>
    <p>Для роботи з Unicode, часто вигідніше використовувати програмні бібліотеки
      , які призначені для підтримки Unicode. Старі бібліотеки можуть не так добре підтримувати Unicode
      , або взагалі не підтримувати.</p>
  </section>
  <section>
    <h3 id="language"><a href="#language">Визначення та 
      призначення мови</a></h3>
    <p>Хоча Unicode дозволяє багатомовні програми і документи, є
      багато процесів, які вимагають знання про використання фактичної мови. Такі 
      процеси варіюються від простого складання до пошуку та перевірки
      правопису.</p>
    <p>APIs, що базуються на основі Unicode мають дозволяти специфікацію  
      мови (мов), що використовується там де тільки такі знання можуть знадобитися і мова
      контенту створеного користувачами повинна бути записана там де це можливо. 
      Там де не можна визначити мову в ресурсі, може знадобитися бібліотека визначення 
      мови.</p>
    <p>Щоб допомогти іншим програмам, мову веб-контенту,
      потрібно призначати з використанням HTTP заголовку <code class="kw" translate="no">Content-Language</code> або HTML/XML атрибутів <code class="kw" translate="no">lang</code>.</p>
  </section>
  <section>
    <h3 id="fonts"><a href="#fonts">Питання щодо шрифтів</a></h3>
    <p>При заданні шрифтів веб сайти, що використовують Unicode повинні бути більш обережні
      ніж веб сайти, що використовують застарілі кодування. Багато мов мають унікальні або специфічні
      писемні традиції, навіть якщо вони поділяють скрипт з іншими мовами. В
      інших випадках, підтримка шрифтів може бути перешкодою, тому що шрифти необхідні для
      відображення певних скриптів не встановлені на більшості систем.</p>
    <p>Наприклад, Китайські і Японські системи письма мають велику кількість
      символів, але мають різні друкарські традиції, так що Китайські 
      шрифти, як правило, не прийнятні для тексту Японською мовою, і навпаки. 
      Наприклад, є той самий символ, відображений за допомогою Китайського і 
      Японського шрифта (разом із HTML кодом, що використовується для створення знімка
      екрана):</p>
    <div class="example">
      <p><img src="index-data/zhs-jpn-font.jpg" height="53" width="105"
alt="Зображення того ж ідеографічного символу Unicode, але з двома різними представленнями гліфів."
/></p>
      <p><code>&lt;span style="font-size:3em;font-family:sans-serif;"&gt;<br />
        &lt;span lang="zh-Hans-CN" style="font-family: simsun, hei,
        sans-serif;"&gt;з›直&lt;/span&gt;<br />
        &lt;span lang="ja" style="font-family: 'ms gothic',
        osaka;"&gt;з›直&lt;/span&gt;<br />
        &lt;/span&gt;</code></p>
    </div>
    <p>Коли використовуються застарілі кодування браузери часто вгадують мову із
      кодування і вибирають відповідний шрифт.</p>
    <p>Оскільки Unicode підтримує як Китайську так і Японську мови, цей прийом не працює 
      для сторінок, закодованих в Unicode, а результатом може бути недоречний шрифт або
      навіть неладне поєднання шрифтів, що використовуються для відображення контенту.</p>
    <p>Одне з рішень - слідкувати за мовою, що використовується, і 
      передати браузеру мову і шрифти, що використовуються для  
      мови. Для одномовних сторінок простий і ефективний підхід - використання для мови 
      спеціальної таблиці стилів. Для багатомовних сторінок, ви повинні використовувати
      атрибут <code class="kw" translate="no">lang</code> HTML тегів для визначення мови; кілька браузерів 
      використовують цю інформацію для вибору правильного шрифту. Для точного 
      контролю над шрифтом ви також можете використовувати класи для визначення мови та 
      клас селекторів в таблиці стилів, щоб встановити шрифт. CSS 2.1 селектори
      псевдо класу мови, які будуть вибирати безпосередньо на основі атрибуту(ів) 
      мови, не підтримуються Internet Explorer і тому мають обмежену корисність. 
      Дивіться <a 
href="http://www.w3.org/International/tests/results/css-lang">Результати тестування: Залежний від мови стайлінг</a>.</p>
  </section>
</section>
<section>
  <h2 id="migrating"><a href="#migrating">Перенесення даних</a></h2>
  <p>Перетворення даних, пов'язаних з продуктом, у багатьох випадках може бути 
    найбільшою проблемою в переході продукту в Unicode. Наприклад, деякі
    програми володіють або мають доступ до ряду баз даних, деякі з яких управляються
    такими двигунами баз даних як Oracle або MySQL. Інші використовують власні формати
    файла і механізми доступу. Ці бази даних, незалежно від типу необхідно 
    перенести для підтримки Unicode.</p>
  <p>При перенесенні даних в Unicode добре було б об'єднати 
    бази даних, що були раніше окремими через різні 
    кодування символів. Використання єдиної бази даних по всьому світу або тільки декількох для
    основних регіонів може спростити розгортання і обслуговування, і може дозволити
    обмін контентом між різними ринками, і Unicode ідеально підходить для цього оскільки він
    може представляти текст на всіх мовах. Однак при об'єднанні ви повинні мати на увазі, 
    що інші обмеження пов'язані з розподілом контенту можуть залишатися: 
    доступність мови, умови ліцензування, а також юридичні або культурні
    обмеження на публікацію матеріалів, пов'язаних із політикою, релігією, статтю і
    насильством.</p>
  <p>Стратегії для перетворення даних будуть змінюватися в залежності від ряду
    факторів:</p>
  <ul>
    <li>Чи всі дані в базі даних використовують те ж саме кодування, чи різні 
      кодування.</li>
    <li>Чи відомо кодування даних чи ні.</li>
    <li>Чи залежить від знань про кодування символів доступ до даних або 
      інші функції, що реалізовані в базі даних, чи ні. Наприклад, 
      індекси на текстових полях в цілому залежать від кодування символів і
      мови, в той час як індекси на числових полях не залежать.</li>
    <li>Розмір даних.</li>
    <li>Реплікація даних.</li>
    <li>Uptime (безвідмовна робота) вимоги.</li>
  </ul>
  <p>Через варіації в цих факторах  не існує простого рецепту, якого 
    необхідно дотримуватися при перетворенні бази даних продукту. Нижче 
    обговорення загальних міркувань; однак, як правило, необхідно 
    створити план конверсії з урахуваннями для кожного продукту. Такий план, 
    швидше за все, матиме кілька фаз для аналізу і перетворення з перевіркою
    результатів перетворення, і відновленням, якщо щось піде не так.</p>
  <section>
    <h3 id="sizeissues"><a href="#sizeissues">Вирішення питань щодо 
      розміру тексту</a></h3>
    <p>Як уже згадувалося в <a href="#textsize">Питання щодо Розміру Тексту</a> (вище),
      перетворення тексту в Unicode, як правило, відбувається за вимог розширеного
      вмістилища, і ви повинні ретельно розглянути питання про доцільність вимірювання
      довжини тексту в байтах, символах або UTF-16 code units (елементи коду). Щоб зменшити вплив 
      збільшених розмірів поля перемкніть CHAR поля в базах даних SQL 
      на VARCHAR, що дозволить базі даних виділити стільки 
      простору скільки необхідно.</p>
    <p>При вимірюванні тексту, деякі бази даних не дають вам вибору. Наприклад,
      MySQL завжди вимірює з точки зору Unicode BMP символів, в результаті чого виходить 3
      байти на символ. Інші, такі як Oracle, дозволяють вибирати між семантикою символа
      або байта. Інші системи зберігання даних, які накладають обмеження на розмір швидше за все
      вимірюють в байтах.</p>
    <p>Під час перенесення, яке включає в себе перекодування, будьте обережні, щоб 
      уникнути скорочення. У деяких випадках, на жаль, ви не зможете це зробити, 
      через такі зовнішні обмеження, як 30 байтний ліміт в Oracle для
      схеми імен об'єктів у словниках даних (використання символів ASCII для схеми
      імен допомагає уникнути цієї проблеми). В таких вападках, принаймні переконайтесь, у скороченні 
      в межі символу.</p>
    <p>Крім того: зверніть увагу, що можуть бути розширення тексту за рахунок перекладу. Дивіться <a
href="/International/articles/article-text-size">Розмір тексту в перекладі</a>.</p>
  </section>
  <section>
    <h3 id="asciidata"><a href="#asciidata">Виявлення ASCII 
      даних</a></h3>
    <p>Варто визначати набори даних (файли, таблиці бази даних, стовпчики бази даних),
      які повністю закодовані в ASCII. Якщо потрібне Unicode кодування - 
      UTF-8, то для таких наборів даних перетворення не потрібно, оскільки послідовності 
      байтів ASCII ідентичні відповідним послідовностям байтів UTF-8. Крім того,
      індекси над ASCII текстовими полями справедливі і для відповідних UTF-8 або
      UTF-16 текстових полів, якщо тільки вони не базуються на порядку сортування чутливому до мови.
      Тим не менше, ви повинні бути строгими у визначенні ASCII наборів даних. Термін 
      "ASCII" часто помилково використовується для таких речей, які не є ASCII, такі як звичайний
      текст (в будь-якому кодуванні) або текст в таких кодуваннях, як ISO 8859-1 або 
      Windows-1252. Крім того, ряд кодувань символів був розроблений, щоб вписатися в
      7-бітні послідовності байтів, представляючи абсолютно різні набори символів 
      із ASCII.</p>
    <p>Щоб переконатися, що набір даних дійсно знаходиться в ASCII, перевірте 
      наступне:</p>
    <ul>
      <li>Всі значення байтів в наборі даних знаходяться в діапазоні від 0x00 до 0x7F.
        ASCII не використовує значення байтів вище за 0x7F.</li>
      <li>
        <p>Не використовуються такі значення байтів, як 0x0E, 0x0F, та 0x1B.
          Присутність цих значень байтів, швидше за все, вказує, що дані
          насправді закодовані в <a href="http://en.wikipedia.org/wiki/ISO_2022">кодуванні 
          ISO-2022</a>.</p>
      </li>
      <li>
        <p>Якщо символи "+" та "-" зустрічаються, то проміжні 
          байти не дійсні для BASE-64. Якщо вони є, то не виключено, що
          текст закодований в <a href="http://en.wikipedia.org/wiki/UTF-7"> кодуванні 
          UTF-7</a>. Зверніть увагу, що UTF-7 по можливості треба уникати 
          через потенціальну загрозу XSS атак.</p>
      </li>
      <li>
        <p>Такі послідовності символів, як "~{" та "~}" не зустрічаються.
          Якщо ви їх зустріли, то текст, ймовірно, закодований в <a
    href="http://en.wikipedia.org/wiki/HZ_%28character_encoding%29">кодуванні
          HZ</a>.</p>
      </li>
    </ul>
  </section>
  <section>
    <h3 id="uncertainty"><a href="#uncertainty">Дії в умовах 
      невизначеності</a></h3>
    <p>Як згадувалося раніше, іноді трапляється, що бази даних містять текст 
      кодування якого не відоме. Виявлення кодування символів можна використати 
      для отримання уявлення про кодування, але цей процес не є надійним. Щоб справитися з
      невизначеністю, необхідно виконати ряд додаткових кроків:</p>
    <ul>
      <li>Виконати спробу для оцінки точності визначення кодування. Використовуйте
        алгоритм виявлення, який ви збираєтеся використовувати на підмножину даних, 
        перетворіть дані з виявленого кодування в Unicode, і для перевірки результатів 
        потрібні люди, які знайомі із мовами, які використовувалися. Якщо точність
        не відповідає вимогам, спробуйте інші алгоритми визначення кодування або 
        використовуйте додаткову інформацію, що доступна для вашої програми.</li>
      <li>Якщо ваші дані містять інформацію пов'язану із кодуванням (але ви 
        не повною мірою їй довіряєте), зосередьте увагу на випадках, коли алгоритм виявлення
        розпізнає різні кодування. Це може допомогти вам зосередитися на необхідних 
        поліпшеннях у використанні додаткової інформації.</li>
      <li>Після перенесення забезпечте способи для пізнішого виправлення кодування.  
        Одне з рішень полягає в забезпеченні користувацького інтерфейсу, який дозволяє користувачеві
        вказувати фактичне кодування, яке потім зберігається з текстом і використовується
        для перетворення тексту. Для цього вам потрібно зберегти доступними оригінальні 
        послідовності байтів, поряд з ім'ям виявленого кодування.
        Незалежно від того, збереження версії тексту в Unicode залежить від того, наскільки часто
        текст доступний - для тексту, до якого звертаються часто, можливо варто буде 
        caching (кешувати) Unicode версію, а для іншого тексту можливо
        краще зберегти вмістилище і регенерувати Unicode версію 
        коли це необхідно. </li>
    </ul>
    <p>Для простоти, наступні розділи передбачають, що кодування може бути 
      точно визначено і, отже, перетворення є одноразовим заходом. Там де
      це не так, стратегії повинні бути скоректовані.</p>
  </section>
  <section>
    <h3 id="ncrs"><a href="#ncrs">Значення Numeric Character References 
      (Числових Посилань)</a></h3>
    <p>Бази даних зберігаючи створений користувачами контент, часто містять числові посилання
      (NCRs) на введені користувачами символи відмінні від ASCII такі, як
      "&amp;#x0152;" (Œ) або &quot;&amp;#x20AC;&quot; (€). Багато браузерів створюють NCRs тоді, коли
      користувачі вводять текст в поля форми, які не можуть бути виражені у 
      кодуванні символів форми. NCRs відмінно працюють, якщо текст згодом перепоказаний в 
      HTML. Однак, для інших процесів, вони не працюють тому, що вони не збігаються 
      із текстом, який вони представляють в пошуку, вони сортуються в неправильному місці, або 
      вони ігноруються разі перетворення. При переході на Unicode також
      було б добре перетворити NCRs у відповідні символи Unicode. Однак, ви повинні бути
      обережні, щоб уникнути перетворень, які змінюють значення
      тексту (перетворення із "&amp;amp;" в "&amp;") або перетворення в
      текст який буде відфільтрований з міркувань безпеки.</p>
  </section>
  <section>
    <h3 id="bom"><a href="#bom">Використання BOM (маркер порядку байтів)</a></h3>
    <p>Під час переходу із застарілих кодувань в Unicode, прийнято використовувати
      застарілі кодування та Unicode паралельно, і ви повинні 
      розрізняти їх. У загальному випадку, це вимагає специфікацій
      кодування символів. Проте, якщо вам потрібно відрізнити тільки одне 
      певне застаріле кодування (наприклад, старе кодування сайту за замовчуванням) і UTF-8,
      ви можете використовувати Unicode Маркер Порядку Байтів (BOM) в якості префікса для ідентифікації 
      рядків UTF-8. Це особливо зручно, якщо немає застереження про специфікацію 
      кодування символів, наприклад, в звичайних текстових файлах або в cookies (куки). 
      BOM в UTF-8 - послідовність байтів 0xEF 0xBB 0xBF, яка б навряд чи знадобилася б
      в будь-якому застарілому кодуванні.</p>
    <p>Зчитувач даних, який ідентифікує їх кодування, таким чином, для визначення 
      кодування читає перші три байти. Якщо байти відповідають BOM, то три
      байти зачищаються і контент, що залишився повертається як UTF-8. Якщо байти
      не відповідають BOM, то весь контент перетворюється із застарілого кодування в UTF-8. Однак, ця зачистка не є автоматичною, і це впливає на деякі платформи або мови. Наприклад, PHP файл, який починається з BOM буде витлумачений неправильно PHP процесором. Так що цей трюк краще обмежити і використовувати для відомих частин вашого сайту або коду.</p>
  </section>
  <section>
    <h3 id="plaintext"><a href="#plaintext">Перетворення текстових 
      файлів</a></h3>
    <p>Звичайні текстові файли, які використовують одне кодування легко перетворити.
      Наприклад, інструмент iconv доступний на більшості систем основаних на Unix/Linux. У
      системах, які не мають його, зручно встановити Java
      Development Kit і використовувати його інструмент native2ascii:</p>
    <div class="example"> <code>native2ascii -encoding _''sourceencoding'' ''sourcefile'' |
      native2ascii -reverse -encoding ''targetencoding'' &gt;
      ''targetfile''</code></div>
    <p>Для невеликої кількості файлів, також можна використати редактори: TextPad на Windows,
      TextEdit на Mac, або jEdit на будь-якій платформі, є лише декілька редакторів, які можуть
      перетворювати файли. Зауважимо, що деякі редактори такі, як Notepad (Блокнот), люблять 
      приставляти Unicode byte-order mark (BOM) спереду Unicode файлів, що у випадку
      UTF-8 файлів не є необхідними і може викликати проблеми з програмним забезпеченням, при 
      читанні файлів.</p>
  </section>
  <section>
    <h3 id="structured"><a href="#structured">Перетворення 
      структурованих файлів</a></h3>
    <p>Структуровані файли в даному контексті - будь-які файли, окрім баз даних SQL,
      які мають компоненти, що можуть мати різні кодування або що 
      мають обмежену довжину. Приклади: log files (файли журналу), в яких різні записи можуть
      використовувати різні кодування; повідомлення електронної пошти, де різні заголовки і MIME  
      компоненти можуть використовувати різні кодування, і заголовки мають обмежену
      довжину; і cookies (куки), які часто розглядаються, як такі, що мають кілька полів.
      Для таких файлів, кожен компонент повинен бути перетворений окремо, і обмеження
      довжини мають розглядатися окремо для кожного компонента.</p>
  </section>
  <section>
    <h3 id="sql"><a href="#sql">Перетворення баз даних SQL</a></h3>
    <p>База даних SQL насправді складається з двох компонентів: компонент сервера,
      який фактично керує даними, а також клієнтський компонент, який взаємодіє
      з іншим програмним забезпеченням (наприклад, PHP або Java runtime) і взаємодіє з
      компонентами сервера. Кодування символів, яке клієнт використовує для зв'язку із
      сервером можна встановити окремо від кодування символів, яке використовує
      сервер; сервер перетворить його в разі необхідності.</p>
    <p>Залежно від розміру бази даних та її вимог до безвідмовної роботи, доступні 
      різні стратегії для перетворення:</p>
    <ul>
      <li>Дамп і перезавантаження: вміст бази даних скидається в текстовий
        файл, перетворюється в бажане кодування Unicode, і завантажується в нову
        базу даних. Ця стратегія проста, але працює тільки для баз даних, які можна
        перевести в автономний режим на тривалий період, що необхідний для перетворення.</li>
      <li>Створити нову базу даних Unicode: створюється нова база даних, яка використовує  
        кодування Unicode і поверх копіюється контент із старої бази даних і з ходу
        робиться перетворення. Транзакції, які оновлюють або видаляють контент, який вже 
        скопійований повинні бути відображені в новій базі даних. Коли нова 
        база даних наздоганяє стару, доступ переключається для нової 
        бази даних. Як правило, це найкраща стратегія для виробництва баз даних, 
        але вона вимагає доступності достатньої кількості серверного обладнання баз даних для запуску 
        двох баз даних у паралельному режимі.</li>
      <li>Додати Unicode стовпці: В цій моделі, кожен текстовий стовпчик в 
        застарілому кодуванні спарований з новим стовпчиком в Unicode кодуванні. Поля
        в цьому стовпчику зайняті, а потім ще й змінюються запити для доступу до
        Unicode стовпчика замість стовпчика застарілого кодування. Якщо застаріле
        кодування точно відоме, то стовпчик застарілого кодування можна
        видалити. Ця стратегія може знадобитися, якщо на диску не вистачає місця для створення  
        абсолютно нової бази даних і, якщо код доступу до 
        бази даних прийнятно малий.</li>
      <li>Перетворення на місці: Деякі бази даних, такі як MySQL, мають
        можливість на місці перетворити таблицю з одного кодування в інше. Це
        працює тільки для баз даних, які можна перевести в автономний режим на період, що необхідний 
        для перетворення.</li>
      <li>Перетворення в місці з тегом кодування: Якщо база даних лише
        управляє байтами, і всі інтерпретації байтів як тексту робляться
        за межами бази даних, то можна робити перетворення на місці і
        відстежувати прогрес використовуючи тег кодування на кожному записі. Процеси, які
        мають доступ до бази даних повинні бути проінформовані про тег кодування і перетворювати
        байти, які вони зберігають в базі даних або витягати із бази даних з їх та в їх 
        власні кодування. Якщо база даних містить тільки одне застаріле кодування,
        BOM можна використати, щоб відрізнити Unicode рядки.</li>
    </ul>
    <p>Мова і документація SQL мають погану звичку використовувати 
      термін "character set" (набір символів) для кодувань символів, ігноруючи той факт, що UTF-8
      та UTF-16 (і навіть GB18030) є різними кодуваннями одного й того ж набору
      символів.</p>
    <div class="h4">
      <h4 id="oracle"><a href="#oracle">Особливості Oracle</a></h4>
      <p>Oracle має загальну підтримку Unicode, починаючи з 8-ї версії,
        але підтримка додаткових символів доступна тільки починаючи з
        версії 9r2, і підтримка Unicode 3.2 тільки починаючи з 10-ї версії. Також до 9-ї версії
        трохи важко використовувати такі типи даних, як <code class="kw" translate="no">NCHAR</code> та <code class="kw" translate="no">NVARCHAR</code>. 
        Oracle забезпечує всебічну підтримку Globalization Support Guides (Керівництво Підтримки Глобалізації) для таких
        версій: <a 
href="http://download-west.oracle.com/docs/cd/A91202_01/901_doc/server.901/a90236/toc.htm">9r1</a>, <a 
href="http://download-west.oracle.com/docs/cd/B10501_01/server.920/a96529/toc.htm">9r2</a>, <a 
href="http://download-west.oracle.com/docs/cd/B14117_01/server.101/b10749/toc.htm">10r1</a>,
        та <a 
href="http://download-west.oracle.com/docs/cd/B19306_01/server.102/b14225/toc.htm">10r2</a>.
        Особливо актуальні розділи з питань Character Set Migration (Перехід) та 
        Character Set Scanner (Сканер).</p>
    </div>
    <p>Кодування символів обране для бази даних Oracle встановлюється для
      всієї бази даних, включаючи дані, схеми і запити, з одним винятком: <code class="kw" translate="no">NCHAR</code> та <code class="kw" translate="no">NVARCHAR</code> типи
      завжди використовують Unicode. Для бази даних пропонуються різні Unicode кодування,
      як для цілої бази так і для таких типів даних як <code class="kw" translate="no">NCHAR</code> та <code
class="kw" translate="no">NVARCHAR</code>. Для бази даних правильними є
      UTF-8 під назвою <code class="kw" translate="no">AL32UTF8</code>, та варіант <code
class="kw" translate="no">UTF8</code>, який кодує додаткові символи у вигляді двох 3-байтних 
      послідовностей. Для переходу баз даних в Unicode, ви маєте використовувати <code
class="kw" translate="no">AL32UTF8</code> (бази даних, які вже використовують <code
class="kw" translate="no">UTF8</code> в більшості випадків можуть продовжують це робити - різниця
      між цими кодуваннями може вплинути на параметри сортування та індексації в 
      базі даних, але в цілому це не має великого значення, так як клієнтський інтерфейс 
      перетворює <code class="kw" translate="no">UTF8</code> щоб виправити UTF-8). Для таких типів даних, як <code
class="kw" translate="no">NCHAR</code> та <code class="kw" translate="no">NVARCHAR</code> UTF-16 доступний під назвою <code class="kw" translate="no">AL32UTF8</code>, поряд
      з варіантом кодування <code class="kw" translate="no">UTF8</code>. Семантику
      специфікацій довжини для таких типів даних, як <code class="kw" translate="no">CHAR</code>, <code
class="kw" translate="no">VARCHAR2</code>, та <code class="kw" translate="no">LONG</code> можна
      встановити використовуючи <code class="kw" translate="no">NLS_LENGTH_SEMANTICS</code>, із
      байтовою семантикою за замовчуванням, у той час, як типи даних <code class="kw" translate="no">NCHAR</code> та <code
class="kw" translate="no">NVARCHAR</code> завжди використовують символьну семантику.</p>
    <p>Для правильного перетворення між кодуванням(и), що використовується в межах бази даних в 
      кодуванні клієнта дуже важливо визначити <code
class="kw" translate="no">NLS_LANG</code> змінне середовище на стороні клієнта. Ця
      змінна описує мову, територію, і кодування, що використовується клієнтською
      операційною системою. Oracle має безліч інших параметрів, щоб вказати в базі даних чутливу до 
      локалі поведінку; вони взагалі можуть бути встановлені окремо від кодування 
      до тих пір поки кодування може представляти символи вибраної локалі.
      Unicode підтримує всі мовні стандарти (локалі).</p>
    <p>Oracle забезпечує вбудовану підтримку для кількох стратегій перетворення. 
      Інструмент Character Set Scanner допомагає у виявленні можливого перетворення і
      скороченні проблем в аналізі попереднього перетворення. Утиліти експорту та імпорту
      допомагають у виконанні дампа і перезавантаженні стратегії. Додавати Unicode
      стовпчики легко, тому що <code class="kw" translate="no">NCHAR</code> та <code
class="kw" translate="no">NVARCHAR</code> типи даних підтримують Unicode незалежно від
      кодування бази даних. Перетворення на місці з тегом кодуванням можливе, якщо 
      сама база даних не розтлумачить текст - <code class="kw" translate="no">ALTER
      DATABASE CHARSET</code> заява може бути використана для того, щоб інформувати базу даних про 
      фактичне кодування коли перетворення буде завершено.</p>
    <p>Є повідомлення, що <code class="kw" translate="no">NCHAR</code> типи даних <a
href="http://download-west.oracle.com/otndocs/tech/ias/portal/files/RG/complete_web_site_php_faq2.htm#nchar">не
      підтримуються</a> в PHP Oracle Call Interface.</p>
    <div class="h4">
      <h4 id="mysql"><a href="#mysql">Особливості MySQL</a></h4>
      <p>Щоб отримати підтримку Unicode в базах даних MySQL, ви повинні використовувати
        версію MySQL 4.1 або вищу. Для отримання інформації про перехід на цю версію і 
        про можливі проблеми сумісності дивіться <a 
href="http://dev.mysql.com/doc/refman/4.1/en/charset-upgrading.html">Оновлення
        Character Sets із MySQL 4.0</a>. Детальну інформацію про підтримку 
        кодування символів в MySQL, дивіться в розділі документації MySQL <a 
href="http://dev.mysql.com/doc/refman/4.1/en/charset.html">Підтримка Character 
        Set</a>. Кодування символів  
        для <a 
href="http://dev.mysql.com/doc/refman/4.1/en/charset-syntax.html">контенту бази
        даних</a> можна встанови окремо на рівні сервера, бази даних, таблиці або  
        стовпця. Якщо кодування явно не задане, то воно успадковується від наступного 
        більш високого рівня.</p>
    </div>
    <p>Кодуванням за умовчанням в MySQL є <code class="kw" translate="no">latin1</code>, а саме, ISO-8859-1. Unicode кодування, 
      які підтримуються називаються <code class="kw" translate="no">utf8</code> та <code class="kw" translate="no">ucs2</code>. Зазвичай рекомендованим 
      кодуванням для MySQL має бути <code class="kw" translate="no">utf8</code>. Обидва <code class="kw" translate="no">utf8</code> та <code class="kw" translate="no">ucs2</code> обмежені для
      символів Unicode Basic Multilingual Plane (BMP), так що немає 
      ніякої підтримки для додаткових символів у MySQL. В результаті <code class="kw" translate="no">utf8</code> не є
      повністю сумісною реалізацією UTF-8 (хоча для більшості випадків це
      нормально). Такі типи даних, як <code class="kw" translate="no">NCHAR</code> та <code class="kw" translate="no">NVARCHAR</code> завжди використовують <code class="kw" translate="no">utf8</code>.</p>
    <p>Специфікації довжини для символьних типів даних 
      інтерпретовані до Unicode BMP символів, так специфікація <code>CHAR(5) CHARACTER SET utf8</code> зарезервує 15 байтів. Такі meta дані
      як імена користувачів, завжди зберігаються в UTF-8, тому нелатинські назви можна
      використовувати. Кодування символів для <a 
href="http://dev.mysql.com/doc/refman/4.1/en/charset-connection.html">клієнтського 
      підключення</a> можна встановити окремо для клієнта, підключення, і результатів, але, щоб
      уникнути плутанини, краще встановити їх всі разом, використовуючи <code>SETВ NAMESВ 'utf8'</code>. Кодування <code class="kw" translate="no">ucs2</code> не
      підтримується для клієнтських підключень, так що немає ніяких підстав використовувати це 
      кодування для контенту бази даних.</p>
    <p>Сортування, пов'язані з кодуваннями символів, тому вони
      завжди повинні встановлюватися в той же час, що і кодування. Якщо <code class="kw" translate="no">utf8</code> використовується без вказівки про сортування, то використовується таке сортування за замовчуванням, як <code
class="kw" translate="no">utf8_general_ci</code>. Це застарілий алгоритм 
      сортування, що не є добрим для будь-якої конкретної мови. Сортування <code
class="kw" translate="no">utf8_unicode_ci</code> краще за замовчуванням, так як воно реалізує
      Unicode Collation Algorithm (UCA) і працює для багатьох мов, що спеціально
      не підтримуються названим сортуванням. Ви також можете вибрати одне із
      language-named UTF-8 сортувань, щоб отримати language-specific сортування
      "строго" основане на UCA. Дивіться список сортувань для <a 
href="http://dev.mysql.com/doc/refman/4.1/en/charset-unicode-sets.html">Unicode
      Character Sets</a>. MySQL підтримує <a 
href="http://dev.mysql.com/doc/refman/4.1/en/charset-convert.html">функцію 
      CONVERT</a>, яка дозволяє перетворювати результати запиту із одного
      кодування в інше. MySQL також підтримує перетворення на місці з одного 
      кодування в інше за допомогою <a 
href="http://dev.mysql.com/doc/refman/4.1/en/alter-table.html">ALTER
      statement</a>: <code>ALTER TABLE table CONVERT TO CHARACTER SET
      utf8 COLLATE collation;</code>.</p>
    <div class="sidenoteGroup">
      <p>У деяких випадках, кодування стовпчика в схемі може бути неправильно  
        призначене - наприклад, дані UTF-8 можна зберегти в 
        базі даних MySQL під назвою кодування <code class="kw" translate="no">latin1</code>, раніше MySQL дійсно підтримувала
        UTF-8, або Японські дані можна помітити <code class="kw" translate="no">sjis</code> в той час, коли насправді вони
        використовують Shift-JIS версію Windows, яку MySQL називає <code class="kw" translate="no">cp932</code> (дивіться <a

href="http://dev.mysql.com/doc/refman/4.1/en/charset-cp932.html">The cp932
        Character Set</a> для отримання додаткової інформації з цього приводу). У таких випадках стовпчик
        можна перемаркувати без перетворення шляхом зміни його типу на двійковий 
        еквівалент (<code class="kw" translate="no">BINARY</code>, <code
class="kw" translate="no">VARBINARY</code>, <code class="kw" translate="no">BLOB</code>), потім повернутися назад до 
        символів (<code class="kw" translate="no">CHAR</code>, <code class="kw" translate="no">VARCHAR</code>, <code class="kw" translate="no">TEXT</code>) з правильною назвою кодування, наприклад, для <code class="kw" translate="no">TEXT</code> стовпчика: <code>ALTER TABLE table CHANGE
        column column BLOB; ALTER TABLE table CHANGE column column TEXT
        CHARACTER SET utf8 COLLATION collation;</code>. Ви можете і повинні змінити  
        разом всі стовпці однієї таблиці для того, щоб звести до мінімуму витрати на 
        перебудову таблиці.</p>
      <div class="sideinfonote"><p class="info">Примітка: PHP клієнт для MySQL за замовчуванням вказує <strong>latin1</strong> як кодування для кожного нового з'єднання, тому необхідно
        вставити заяву <code>SET NAMES 'utf8'</code> для кожного нового з'єднання.</p></div>
    </div>
  </section>
  <section>
    <h3 id="filenames"><a href="#filenames">Перетворення імен 
      файлів</a></h3>
    <p>Кілька серверних операційних систем (наприклад, !FreeBSD, Red Hat) зберігають
      імена файлів, як прості послідовності байтів, які тлумачаться як 
      процеси вищого рівня. Серверні процеси можуть інтерпретувати послідовності байтів відповідно 
      до кодування символів локалі в якій вони виконуються, або просто передати їх 
      клієнтським процесам. Тому фактичне кодування потрібно визначити
      шляхом оцінки того, як було створено назву, що для окремого сайту або користувача може бути через  
      веб сторінку в кодуванні за замовчуванням. Якщо це вас не переконає,  
      то використайте виявлення кодування.</p>
    <p>Якщо точно можна визначити кодування імені файла, то його можна 
      перетворити в UTF-8, та Byte Order Mark можна використати, щоб помітити його як
      перетворений. Якщо кодування не визначене, можливо знадобиться створити
      базу даних паралельно до файлової системи для запису виявленого кодування та, 
      можливо, UTF-8 версії, так що оригінальне ім'я файлу може зберігатися неподалік 
      для подальшого виправлення кодування.</p>
  </section>
</section>
<section>
  <h2 id="testing"><a href="#testing">Тестування за допомогою Unicode</a></h2>
  <p>Не має сенсу тестувати Unicode підтримку з ASCII текстом. Переконайтеся, що ви
    перевіряєте обробку даних користувача з текстом на різних мовах, які ви будете 
    підтримувати:</p>
  <ul>
    <li>Латинські символи відмінні від ASCII: <span lang="fr">élève</span>, <span lang="de">süß</span>, <span lang="tr">İstanbul</span>, <span lang="da">Århus</span>,
      ©®€“”’«»</li>
    <li>Східноєвропейські системи письма: <span lang="el">ελληνικά</span>, <span lang="ru">русский</span></li>
    <li>Східно-Азіатські мови: <span lang="zh-hans">中文</span>, <span lang="ja">日本語</span>, <span lang="ko">한국어</span></li>
    <li>Південно-Східні Азіатські мови: <span lang="vi">Tiếng Việt</span>, <span lang="th">ไทย</span></li>
    <li style="text-align: left;">Індійські мови: <span lang="hi">हिंदी</span></li>
  </ul>
  <p>Тестування із цими мовами вимагає, щоб ваш комп'ютер був налаштований 
    для їх підтримки. <a
href="http://www.inter-locale.com/whitepaper/learn/learn_to_type.html">Вчимося 
    Друкувати Японською та Іншими Мовами</a> містить інформацію про те, як це зробити
    для всіх поширених операційних систем.</p>
  <p>Щоб показати, що текст в користувацькому інтерфейсі вашої програми обробляється
    правильно, корисною буде така стратегія тестування, як псевдо-локалізація.
    Інструменти псевдо-перекладу можуть автоматично замінювати ASCII символи на 
    повідомлення користувацького інтерфейсу із еквівалентними Латинськими символи на всю ширину із
    Unicode діапазону від U+FF01 до U+FF5E (English -&gt; Ｅｎｇｌｉｓｈ) або з
    іншими літерами із діакритичними знаками з повного Латинського діапазону (English
    -&gt; Ëñgłíšh).</p>
  <p>Питання, які вимагають особливої уваги при тестуванні підтримки 
    Unicode:</p>
  <ul>
    <li>Збереження введеного користувачем тексту на всьому шляху від введення тексту на
      клавіатурі за допомогою програм і бази даних до повторного відображення.</li>
    <li>Скрізь правильна специфікація кодувань символів.</li>
    <li>Виявлення застарілих кодувань, а також корекція неправильно визначених 
      кодувань.</li>
    <li>Перетворення в інші формати, наприклад, від форми введення до RSS каналу.</li>
    <li>Пошук тексту, зокрема, пошуки, які не просто порівнюють послідовності 
      байтів, наприклад, пошук без урахування регістру або пошук "схожого" тексту, у тому числі
      включаючи введення даних в різних формах нормалізації.</li>
    <li>Сортування рядків, включаючи рядки в різних формах
      нормалізації.</li>
  </ul>
  <p>Деякі керівні принципи для тестування Unicode підтримки та інтернаціоналізації 
    можна знайти на: <a
href="http://www.inter-locale.com/whitepaper/learn/learn-to-test.html">Міжнародні Основи 
    Тестування</a></p>
</section>


<section>
<h2 id="endlinks"><a href="#endlinks">Further reading</a></h2>
<aside class="section" id="survey"> </aside><script>document.getElementById('survey').innerHTML = g.survey</script>

  <ul id="full-links">
    <li>
      <p><a
    href="http://dev.mysql.com/doc/refman/4.1/en/charset.html">Підтримка Character 
        Set</a> для MySQL.</p>
    </li>
    <li>
      <p><a
    href="http://www.inter-locale.com/whitepaper/learn/learn_to_type.html">Вчимося
        Друкувати Японською та Іншими Мовами</a> містить інформацію про настроювання
        та використання всіх поширених операційних систем для багатомовного тестування.</p>
    </li>
  </ul>
</section>

<footer id="thefooter"></footer><script type="text/javascript">document.getElementById('thefooter').innerHTML = g.bottomOfPage</script>
<script type="text/javascript">completePage()</script>
</body>
</html>

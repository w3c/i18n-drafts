<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<title>Переход на Unicode</title>
<meta name="description" content="Эта W3C I18n статья дает рекомендации по переходу программы и данных в Unicode. Она охватывает планирование перехода, и проектирование и применение программного обеспечения Unicode." />
<script type="text/javascript">
var f = { }

// AUTHORS should fill in these assignments:
f.directory = 'articles/unicode-migration'+'/'; // the path to this file, not including /International or the file name
f.filename = 'index'; // the file name WITHOUT extensions
f.authors = 'Norbert Lindenberg, Yahoo!; Editor: Addison Phillips, Yahoo!'; // author(s) and affiliations
f.previousauthors = ''; // as above
f.modifiers = ''; // people making substantive changes, and their affiliation
f.searchString = 'article-unicode-migration'; // blog search string - usually the filename without extensions
f.firstPubDate = '2008-04-11'; // date of the first publication of the document (after review)
f.lastSubstUpdate = { date:'2008-04-11', time:'10:19'}  // date and time of latest substantive changes to this document
f.status = 'published';  // should be one of draft, review, published, notreviewed or obsolete
f.path = '../../' // what you need to prepend to a URL to get to the /International directory 

// AUTHORS AND TRANSLATORS should fill in these assignments:
f.thisVersion = { date:'2016-01-31', time:'06:01'} // date and time of latest edits to this document/translation
f.contributors = ''; // people providing useful contributions or feedback during review or at other times
// also make sure that the lang attribute on the html tag is correct!

// TRANSLATORS should fill in these assignments:
f.translators = 'Alexandr Shlapak (Александр Шлапак)'; // translator(s) and their affiliation - a elements allowed, but use double quotes for attributes

f.breadcrumb = 'characters';

f.additionalLinks = ''
</script>
<script type="text/javascript" src="index-data/translations.js"> </script>
<script type="text/javascript" src="../../javascript/doc-structure/article-dt.js"> </script>
<script type="text/javascript" src="../../javascript/boilerplate-text/boilerplate-ru.js"></script><!--TRANSLATORS must change -en to the subtag for their language!-->
<script type="text/javascript" src="../../javascript/doc-structure/article.js"> </script>
<script type="text/javascript" src="../../javascript/articletoc-html5.js"></script>
<link rel="stylesheet" href="../../style/article-2016.css" type="text/css" />
<!-- remove the following local css declaration if there is nothing to add -->
<link rel="stylesheet" href="filename-data/local.css" type="text/css" />
<link rel="copyright" href="#copyright"/>
<!--[if lt IE 9]><script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>

<body>
<header>
  <nav id="mainNavigation"></nav><script>document.getElementById('mainNavigation').innerHTML = mainNavigation</script>
  
  <h1>Переход на Unicode</h1>
</header>


<section>
  <div id="audience">
    <p><span id="intendedAudience" class="leadin">Intended audience:</span> 
    Веб-разработчики, программисты, администраторы
      сайтов, и другие желающие перевести Веб сайт или Веб контент
      из устаревшей (non-Unicode) кодировки символов на Unicode. </p>
    <div id="updateInfo"></div><script>document.getElementById('updateInfo').innerHTML = g.updated</script>
    </div>
    
  <p>Эта статья дает рекомендации по переходу программы и данных в
    Unicode. Она охватывает планирование перехода, и проектирование и применение
    программного обеспечения Unicode. Предполагается общее представление о Unicode и принципах
    кодировки символов. Некоторые источники информации об этом
    включают в себя: </p>
  <ul>
    <li><a class="print" href="http://www.unicode.org/">Консорциум Unicode</a></li>
    <li><a class="print" href="http://www.w3.org/TR/CharMod">W3C Модель Символа</a></li>
    <li><a
    class="print" href="http://www.inter-locale.com/whitepaper/IUC-Intro-to-I18N-Tutorial.pdf">Пособие
      Интернационализации</a></li>
  </ul>
</section>


<section>
  <h2 id="why"><a href="#why">Зачем переходить на Unicode?</a></h2>
  <p>Есть несколько причин для принятия Unicode:</p>
  <ul>
    <li>Чтобы обработать текст необходимо его понимать, поэтому
      процесс обработки зависит от кодировки символов. Unicode обеспечивает прочную основу
      для обработки текста со всего мира, тогда как другие кодирования требуют
      отдельных реализаций для каждой кодировки и каждая из них поддерживает только ограниченный набор 
      языков. Соответственно использование Unicode также облегчает
      распределение программным обеспечением для обработки текста по всему миру.</li>
    <li>Некоторые программы поддерживают связь и сотрудничество
      между пользователями, проживающими в разных частях света и используют различные
      языка. Unicode - стандарт, который всем в мире, предоставляет связь  
      без ограничений, накладываемых языком, которым общается пользователь или регионом, в котором 
      живут пользователи. </li>
    <li>Поскольку многие языки не поддерживаются, кодировками символов 
      отличными от Unicode, то иногда пользователи представляют созданный ими контент (такой
      как form data) в кодировках, отличных от поддерживаемых (например,
      путем изменения кодировки браузера). Это препятствует программе
      правильно обрабатывать текст, например, при его поиске в 
      базе данных, или при выборе рекламы для размещения за ним.</li>
    <li>Многие веб-сайты или программные ошибки связаные с кодировками
      символов, так как разные сайты или локализации одного и того же  
      сайта используют различные кодировки символов, и кодировка текстовых данных
      во многих местах неправильная. </li>
  </ul>
  <p>Обратите внимание, что простым изменением кодировки символов ваших страниц в Unicode
    вы не устраните все проблемы с кодировкой символов. На самом деле, при
    переходе существует значительно повышенный риск таких ошибок, потому что
    существующие данные должны быть преобразованы в Unicode, а текущее кодироване известно не
    всегда. Этот документ содержит советы, как минимизировать этот риск и
    как обеспечить механизмы исправления проблем перекодировки.</p>
</section>
<section>
  <h2 id="planning"><a href="#planning">Планирование перехода</a></h2>
  <p>Для возможности перехода на Unicode, вы должны понимать, использование
    кодировок символов в ваших текущих настройках и принять решение о внутреннем и
    внешнее использование кодировок для основанного на Unicode дизайна. Вам также
    нужно знать состояние Unicode поддержки в программных компонентах, на которую вы можете положиться
    и в случае необходимости, спланировать переход для этих компонентов. Это позволяет вам, 
    планировать обновление программного обеспечения, что должно базироваться на основе Unicode и
    преобразование существующих данных в Unicode кодирование.</p>
  <p>Проект перехода на Unicode может быть также хорошим, чтобы улучшить
    интернационализацию в целом. В частности, необходимо рассмотреть вопрос можете ли
    вы использовать многоязычные возможности Unicode, чтобы преодолеть
    ненужные барьеры между различными аудиториями, культурами или языками.
    Особенно для сайтов или программ, которые позволяют общение между пользователями
    и, таким образом принимать или передавать контент, созданный пользователями, есть смысл создать
    один сайт с общим многоязычным контентом несмотря на
    несколько локализованных пользовательских интерфейсов.</p>
</section>
<section>
  <h2 id="understanding"><a href="#understanding">Понимание текущего использования
    кодировок символов</a></h2>
  <p>Для начала, вы должны хорошо понимать как кодировка символов используются
    в вашем программном обеспечении. Определить компоненты
    программы и вместилища данных: передняя часть, задняя часть, вместилище, APIs(прикладные программные интерфейсы), веб
    интерфейсы, и т.д., и выяснить их использование в кодировках:</p>
  <ul>
    <li>Какие компоненты уже основаные на Unicode? Какая кодировка Unicode 
      используется (UTF-8 или UTF-16)? Какие компоненты используют устаревшие(т.е. отличные
      от Unicode) кодировки? </li>
    <li>Какие потоки данных между компонентами, и какие кодировки
      используются в каждом случае?</li>
    <li>Какие кодировки определены для интерфейсов между
      компонентами?</li>
    <li>Какие кодировки, определенные для внешних интерфейсов
      программного обеспечения?</li>
    <li>Где происходит перекодировка?</li>
    <li>Четко ли разделены единицы текста, которые используют различные кодировки, 
      или кодирования указанные в каждой точке, или существуют возможности  
      для сохранения или обработки текста в разных или неизвестных кодировках?</li>
  </ul>
  <p>Последний вопрос может показаться странным, но он особенно важен. Отсутствие
    достоверной информации о кодировке символов, которая используется для текста,
    поступающего извне сайта (такого, как каналы контента или данные введенные пользователем) или,
    или, то, что уже в ваших коллекциях данных является общей проблемой и требует
    особого внимания. (На самом деле, вам нужно обратить внимание на эти вещи,
    даже если вы не превращаете данные в Unicode.) Существуют разные случаи, когда
    может произойти это отсутствие правильной информации:</p>
  <ul>
    <li>Данные из вне могут вообще не определить кодировку. 
      Это очень распространенная проблема для электронной почты, веб-страниц, или каналов данных.</li>
    <li>Данные из вне могут не правильно определить кодировку.
      Это также общая проблема для электронной почты и веб-страниц.</li>
    <li>Веб-приложения могли присвоить кодировку для формы 
      подачи, но пользователи действительно изменили кодировку в браузере.
      Пользователи часто это делают, когда кодирование, которое используется веб-приложением
      не поддерживает язык пользователя, например, приложение поддерживает только
      ISO 8859-1, а пользователь хочет использовать нелатинские скриптовые языки, такие
      как Греческий, Русский, Хинди, Китайский, и так далее.</li>
    <li>Кодирование было известно в определенный момент, но затем эта информация
      потерялась. Это обычная ситуация с log files (файлы журнала) - веб-приложение
      возможно, не знало (или хотя би правильно предпологало) кодировку, которая
      используется для HTTP запроса, но сам запрос и, следовательно, запись
      журнала не содержат эту информацию.</li>
    <li>Данные пропускали через интерфейс в одной кодировке, где
      интерфейс на самом деле требует другую кодировку. Примером может служить
      хранение информации о пользователе закодированной с помощью UTF-8 в базе данных
      ISO 8859-1.</li>
  </ul>
  <p>Чтобы справиться с такими ситуациями, обычно используется выявление кодирования
    символов. Попытки обнаружения кодирования используются в последовательности байтов 
    основанной на характеристиках самой последовательности байтов. В большинстве случаев 
    это статистический процесс, требующий для хорошей работы долгих входных последовательностей байтов,
    хотя вы сможете улучшить его точность при использовании другой доступной для
    вашего приложения информации. Из-за высокой вероятности ошибок, для людей часто
    необходимо предусматривать способы их обнаружения и исправления. Это 
    требует доступности оригинальной последовательности байтов для дальнейшей реконверсии.
    Примеры библиотек определения кодировки включают в себя:</p>
  <ul>
    <li><a
  class="print" href="http://www.mozilla.org/projects/intl/chardet.html">Mozilla</a></li>
    <li><a
  class="print" href="http://icu-project.org/userguide/charsetDetection.html">ICU</a></li>
  </ul>
</section>
<section>
  <h2 id="checking"><a href="#checking">Проверка устоев</a></h2>
  <p>Реализация программного обеспечения часто зависит от другого программного обеспечения:</p>
  <ul>
    <li>языки программирования и связанные с ними библиотеки,</li>
    <li>движок базы данных,</li>
    <li>программные платформы или библиотеки на которых базируется ваше программное обеспечение,</li>
    <li>другие сайты или приложения с которыми взаимодействует ваше программное обеспечение,</li>
    <li>сторонние библиотеки, </li>
    <li>инструменты, которые вы используете для создания, тестирования и развертывания программного обеспечения.</li>
  </ul>
  <p>Вы должны проверить поддерживает ли Unicode программное обеспечение от которого вы зависите, или
    по крайней мере не ставит ли вам препятствий в его принятии. Это конечно будет
    необходимым для обновления на новые версии базовых платформ, и в некоторых
    случаях нужно будет перейти с устаревших платформ на 
    новые.</p>
</section>
<section>
  <h2 id="internal"><a href="#internal">Выбрать кодировку для
    внутреннего использования</a></h2>
  <p>Unicode предлагает три формы кодирования: UTF-8, UTF-16, та UTF-32. 
    Обычно для перемещения по сети или для сохранения в файлах UTF-8 работает
    лучше потому, что оно совместимо с ASCII, тогда как похожие на ASCII байты, которые
    содержатся в UTF-16 и UTF-32 тексте - это проблема для некоторых сетевых
    устройств или инструментов обработки файлов. Для обработки в памяти, все три
    формы кодирования могут быть полезными, и лучший выбор часто зависит от
    программных платформ и библиотек, которые вы используете: Java, JavaScript, ICU, и большинство
    Windows APIs (прикладные программные интерфейсы) базируются на основе UTF-16, в то время как Unix системы, как правило, предпочитают UTF-8.
    Размер хранящихся данных редко становится фактором при принятии решения между UTF-8 и UTF-16, поскольку
    оба могут иметь лучший размер профиля, в зависимости от сочетания разметки и
    Европейских или Азиатских языков. UTF-32 является неэффективным для хранения и, следовательно,
    редко используется с этой целью, но оно очень удобно для обработки, и
    некоторые библиотеки, такие как Java и ICU, обеспечили строку доступа и обработки 
    API (прикладные программные интерфейсы) с точки зрения UTF-32 code points (точка кода). Преобразования между тремя формами кодирования
    быстрое и безопасное, так что использование различных форм кодирования в различных компонентах
    больших программных систем вполне реальное и распространенное.</p>
  <p>С уверенностью можно сказать, что сохранение текста, кодирование которого не известно есть
    исключением из единого правила Unicode. Такой текст часто нужно интерпретировать
    используя технологию распознавания кодировки символов. И обнаружения кодирования символов не 
    надежный процесс. Таким образом, вы должны вблизи держать оригинальные байты (наряду с
    выявленным кодированием символов), так чтобы текст можно было повторно преобразовать, когда
    человек изменит кодировку.</p>
</section>
<section>
  <h2 id="externalif"><a href="#externalif">Выбрать кодировку для 
    внешних интерфейсов</a></h2>
  <p>Для взаимодействия вашей программы с внешним миром, UTF-8 нужно
    использовать везде, где это возможно. Однако есть ситуации, когда вы не можете контролировать
    кодирование или нуждаетесь в взаимодействии с системами, которые не поддерживают UTF-8.
    Вот рекомендации для распространенных случаев:</p>
  <ul>
    <li>
      <p><strong class="leadin">Электронная почта:</strong> Вы должны принимать входящие
        письма в любой кодировке, использующей вашей электронной почтой. Для исходящей почты, вам, возможно, придется
        учесть, что многие старые приложения электронной почты не поддерживают
        UTF-8. В настоящее время, исходящая почта должна быть преобразована
        в устаревшее кодирование, которое может отобразить весь ее контент; UTF-8 надо
        использовать только тогда, когда нельзя найти такое устаревшее кодирование. Кодирование
        исходящей почты должно быть указано. Какие выходные кодирования
        использовать зависит от потребностей вашей программы.</p>
    </li>
    <li>
      <p><strong class="leadin">URIs и POST
        данные:</strong> Они используются в нескольких различных контекстах: форма
        подачи, веб-сервисы, или URL-адреса, введенные непосредственно в веб-браузере.
        Для формы подачи, HTML форма должна быть разработана с возможностью обнаружения
        кодирования, даже если пользователь изменит его в браузере. (Вы можете
        использовать JavaScript или специальные значения полей, чтобы определить,
        изменил ли пользователь кодирование: возможно, вы должны мягко напоминать пользователю не делать 
        этого?)</p>
    </li>
    <li>
      <p><strong class="leadin">Веб
        службы:</strong> Веб службы (Особенно Веб службы основанные на REST (передача состояния подачи))
        должны определять использование UTF-8 и отвергать запросы, которые не действительны для UTF-8.
        Для сторонних веб сервисов, используйте UTF-8, если, эта функция поддерживается веб
        сервисом и убедитесь в правильной идентификации используемой кодировки.
        Для URIs (Унифицированный Идентификатор Ресурсов) кодирование вводится непосредственно в веб браузере (например, маркетинговые URIs), 
        другие кодирования возможно нуждаются в поддержке.</p>
    </li>
    <li>
      <p><strong class="leadin">HTML:</strong> При подаче страниц на настольные браузеры, используйте кодировку UTF-8; его поддержка сейчас
        является почти универсальной. Мобильные браузеры не всегда поддерживают UTF-8, так что вы можете
        использовать устаревшие кодировки в зависимости от целевого устройства.
        Кодирование, которое используется должно быть назначено с использованием HTTP: заголовок <code
    class="kw" translate="no">Content-Type</code>, HTML <code
    class="kw" translate="no">meta</code> тэг, либо (предпочтительнее) оба. Если вы не можете контролировать
        конфигурации вашего сервера, на уровне файлов или запросов или не можете настроить
        его для подачи UTF-8 в качестве кодировки, тогда убедитесь, что он вообще
        не отправляет кодировку: клиентские приложения обращают внимание на эту кодировку 
        перед тем как что-то назначить в meta тэг. Правильный HTML <code
    class="kw" translate="no">meta</code> тэг: </p>
      <p
   ><code>&lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8"&gt;</code></p>
      <p>Как установить HTTP <code
    class="kw" translate="no">Content-Type</code> заголовок зависит от вашей среды
        выполнения. Например, в PHP, вы должны использовать: </p>
      <p
   ><code>&lt;?php header("Content-type: text/html; charset=UTF-8"); ?&gt;</code>. </p>
      <p>Смотрите подробную информацию на странице <a 
    class="print" href="http://www.w3.org/International/O-HTTP-charset">установка
        content-type</a>.</p>
      <p>Если вы взяли контент за пределами вашего сайта (например, 
        веб-паук поисковой системы или внешний HTML), то вам придется
        иметь дело с любым кодированием. В некоторых случая
        это означает принятие и обработку используемого кодирования. Если вы включите
        тот материал в свои собственные страницы, то вы должны будете сделать кодирования 
        соответствующим вашей странице (или положить его в тег iframe, где он может использовать свое 
        оригинальное кодирование).</p>
    </li>
    <li>
      <p><strong
    class="leadin">XML:</strong>Исходные XML всегда должны быть закодированы в
        UTF-8; <a class="print" href="http://www.w3.org/TR/REC-xml/#charencoding">XML
        спецификация</a> нуждается, чтобы каждый XML анализатор понимал это. Для источников данных XML,
        кажите использование UTF-8. В других случаях, XML файлы закодированные в
        других кодировках должны быть приняты до тех пор, пока они действительны. Обратите внимание, HTTP Content-Type text/XML по умолчанию US-ASCII (по этому поводу, как правило, отдается предпочтение application/xml+*) и вам все равно нужно указать charset (набор символов), если вы используете text/xml Content-Type.</p>
    </li>
    <li>
      <p><strong class="leadin">JSON:</strong> Исходные данные JSON всегда должны быть закодированы в UTF-8, и желательно в
        ASCII с экранированными символами \u для всех отличных от ASCII символов. Для входных данных,
        может быть также рассмотрена поддержка UTF-16 и UTF-32. <a
    class="print" href="http://www.ietf.org/rfc/rfc4627.txt">Спецификация JSON</a> не
        позволяет любых других кодировок.</p>
    </li>
    <li>
      <p><strong class="leadin">Сериализованая
        PHP:</strong> Этот формат данных, следует избегать, поскольку он не
        позволяет спецификацию кодировки, которая используется, и поэтому, вероятно, может
        привести к повреждению данных отличного от ASCII текста. JSON является хорошей альтернативой.
        Если вы совершенно не можете избежать сериализованой PHP, то укажите кодирование UTF-8 и используйте его.</p>
    </li>
    <li>
      <p><strong class="leadin">Другие каналы 
        данных:</strong> Там где вы можете влиять на кодирование входных
        каналов данных, оно должно быть UTF-8, или по крайней мере хорошо определенным. Там могут 
        быть случаи, когда вы хотите использовать каналы данных, которые вы не можете контролировать, в
        таком случае вам придется использовать все, что вы получите.</p>
    </li>
  </ul>
  <p>Как правило, исходный текст должен быть преобразован в кодирование Unicode как можно 
    быстрее, а исходный текст, если он должен быть отправлен в кодировке отличной от 
    Unicode, надо превратить из Unicode кодирования в то другое кодирование как можно позже.
    Однако, если кодирование входного текста достоверно нельзя 
    определить, тогда оригинальный текст должен быть сохранен вместе с информацией о
    вероятном кодировании. Это позволяет корректировать свои действия, если окажется что
    было выбрано неправильное кодирование.</p>
</section>
<section>
  <h2 id="roadmap"><a href="#roadmap">Создание плана</a></h2>
  <p>Для очень простых сайтов или программ можно изменить
    все программное обеспечение, так чтобы оно основывалось на Unicode, перевести все данные в Unicode
    кодирование, и в один миг переключать с предыдущей версии на Unicode 
    версию. Но многие сайты или программы предлагают внешние интерфейсы,
    имеют большие тела кода и накопили огромные массивы данных, поэтому их
    преобразование - большой проект с несколькими зависимостями, который должен быть
    тщательно спланирован. Вот разбивка на вероятные подпроекты:</p>
  <ul>
    <li>Укажите кодировку, которая используется в существующих APIs (прикладные программные интерфейсы). Поскольку все больше компонентов
      собираются использовать Unicode кодировки, то важно знать, какие
      компоненты этого еще не сделали для того, чтобы избежать повреждения данных.</li>
    <li>Ввести основанные на Unicode версии внешних интерфейсов
      от которых зависит другое программное обеспечение. Это должно быть первым шагом для того, чтобы
      разрешить переход зависимого программного обеспечения. На этом этапе каждый
      внешний интерфейс (API (Прикладной программный интерфейс), веб сервис, поток данных), который базируется на основе устаревших
      кодировок дублируется с параллельным основанным на Unicode интерфейсом. Для многих 
      интерфейсов, первоначальный вариант нового интерфейса просто превращает
      входной текст с Unicode в устаревшее кодирование, которое до сих пор используются,
      вызывает старый интерфейс, и превращает исходный текст из устаревшего  
      кодирование в Unicode. В некоторых случаях, новый интерфейс будет достаточно
      отличается от старого: Например, где старый интерфейс состоит
      из прямого доступа к общим данным, новый интерфейс должен быть API
      (так, инкапсуляция данных является хорошей идеей). Использование устаревших кодировок в
      базовой реализации означает, что поддерживается только подмножество набора символов 
      Unicode - это ограничение должно быть задокументировано, а 
      затем удалено с помощью следующих шагов.</li>
    <li>Поощряйте владельцев других продуктов, которые имеют доступ к вашим 
      базам данных перейти на новый API (Прикладной программный интерфейс). Вам будет лучше чтобы это
      началось как можно раньше потому, что вы не сможете превратить вашу базу данных в Unicode пока
      другие имеют доступ к ней используя устаревшие кодировки.</li>
    <li>Введите уровень абстракции в частные базы данных продукта, 
      основанного на Unicode. Подобно к шагу выше, это позволяет
      превращение реализации вашего продукта, и позволяет идти вперед без 
      ожидания превращения баз данных.</li>
    <li>Преобразование реализации вашего продукта на Unicode. Частью
      этого шага, может быть изменение вашего зовнишнишнього интерфейса таким образом, что теперь
      версии основаные на Unicode будут работать непосредственно с реализацией, в то время
      как версии, основанные на устаревших кодировках будут превращаться в Unicode и с Unicode. Для больших
      сайтов или программы, этот шаг может начаться с основанных на Unicode
      внутренних интерфейсов между подсистемами, подобное тому, что вы сделали для
      внешних интерфейсов выше, так чтобы подсистемы можно было конвертировать
      самостоятельно.</li>
    <li>
      <p>Превращение ваших баз данных и/или хранилищ данных
        в Unicode. Если базы данных были доступны другим продуктам,
        возможно вам придется ждать, пока те продукты перейдут на APIs, которые
        были представлены в первом шаге. Раздел <a
    href="#migratingdata">Передача данных</a> содержит больше информации об этом
        шаге.</p>
    </li>
    <li>Удалите интерфейсы, основанные на устаревших кодировках. Это
      будет заключительный этап вашего перехода, и, в зависимости от того, кто полагается на
      эти интерфейсы, возможно, придется ждать долго.</li>
  </ul>
  <p>Некоторые из этих подпроектов могут выполняться параллельно или в другом 
    порядке, в зависимости от конкретной ситуации вашего продукта. Например, 
    переход реализации вашего продукта может задержаться в
    зависимости от других программных компонентов, которые до сих пор не достаточно
    продвинулись в процессе их перехода. Кроме того базы данных SQL можно
    преобразовать в Unicode гораздо раньше, так как клиентский компонент программного обеспечения  
    базы данных изолирует клиентов от кодирования, используемого в базе данных и
    осуществляет преобразование кодировки символов в случае необходимости. Преобразование баз данных
    на ранней стадии имеет свои преимущества: оно упрощает тестирование, так как базу данных
    можно протестировать независимо от программного обеспечения, которое ее использует, при тестировании программного обеспечения
    более высокого уровня как правило, необходима база данных, и используя устаревшие кодировки
    вы сможете объединить несколько отдельных баз данных в одну многоязычную
    базу данных.</p>
</section>
<section>
  <h2 id="designing"><a href="#designing">Проектирование для Unicode</a></h2>
  <section>
    <h3 id="encodingspecs"><a href="#encodingspecs">Спецификации кодирования 
      символов</a></h3>
    <p>Последовательность байтов может быть правильно интерпретирована как текст, только если
      кодировка символов известна. Многие приложения написаны так, что они просто
      перемещают последовательности байтов, не называя кодировку. Как уже выше было сказано
      это всегда вызывает проблемы. Но это случается в случаях,
      когда все пользователи общаются на одном языке или готовы адаптироваться к некоторому
      неправильно сделанному контенту на странице. В процессе перехода на
      Unicode, каждый язык будет обрабатываться как минимум в двух кодировках,
      устаревшее кодирование для языка и UTF-8, так что указание кодировки
      для каждой последовательности байтов будет иметь решающее значение для того, чтобы
      избежать лавины ошибок повреждения данных.</p>
    <p>Кодирование символов можно задать разными способами:</p>
    <ul>
      <li>
        <p>В спецификации формата: спецификация для
          формата данных может указать кодировку или напрямую, или 
          указать простой детерминированный механизм для определения кодировки символов
          смотря на начало последовательности байтов. Примерами являются
          спецификация <a
    class="print" href="http://java.sun.com/javase/6/docs/api/java/lang/String.html">Java
          String class</a>, которая определяет UTF-16, и <a
    class="print" href="http://www.ietf.org/rfc/rfc4627.txt">спецификация JSON</a>, которая
          приписывает использование Unicode кодировок и как их 
          различать.</p>
      </li>
      <li>
        <p>В рамках последовательности байтов: Спецификация
          для формата данных может предусматривать механизм для указания 
          кодировки как части последовательности байтов. XML
          спецификация делает это в элегантный способ используя <a 
    class="print" href="http://www.w3.org/TR/2006/REC-xml-20060816/#charencoding">назначение
          кодирования</a>, HTML спецификация делает это в менее элегантный способ используя <code class="kw" translate="no"><a
    class="print" href="http://www.w3.org/TR/html401/charset.html#h-5.2.2">meta</a></code> тэг. Для форматов данных, которые позволяют такую ​​спецификацию, данные могут содержать
          спецификацию кодировки, если только последовательность байтов в кодировке - UTF-8 и
          спецификация обеспечивает правильное выявление UTF-8 (как для XML). для HTML
          файлов <code class="kw" translate="no">meta</code> тэг указывает content type
          и кодирование должно быть первой подкатегорией элемента <code
    class="kw" translate="no">head</code> , и перед ним не должны стоять символы отличающиеся от
          ASCII.</p>
      </li>
      <li>
        <p>В данных, которые являются внешними по отношению к последовательности байтов:
          Во многих случаях, вместилище последовательности байтов обеспечивает спецификацию 
          кодирования. Несколько примеров будут включать в себя HTTP или MIME, где поле <code class="kw" translate="no"><a
    class="print" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type</a></code> заголовок может указать кодировку и базы данных, где 
          кодирования указано как часть схемы или конфигурации 
          базы данных. Опять же, где такие возможности существуют, текстовые данные должны
          использовать их. В некоторых случаях, таких как отправка HTML через HTTP
          внешняя спецификация кодирования может дублировать то, что является частью последовательности  
          байтов - это хорошо, так как веб браузеры предпочитают  
          заголовку HTTP, в то время как <code class="kw" translate="no">meta</code> тэг - единственная
          спецификация, которая сохраняется при сохранении файла на диск.</p>
      </li>
      <li>
        <p>В спецификациях интерфейса: Спецификации интерфейсов,
          которые принимают или возвращают последовательности байтов без всяких спецификаций
          кодировки могут (и должны) указывать используемое 
          кодирование. Спецификация может быть абсолютной или относительной по отношению к 
          среде установки. Например, некоторые библиотеки предоставляют функции, которые
          принимают или возвращают строки в UTF-8, в то время как другие принимают или возвращают строки 
          закодированными в некоторые устаревшие кодировки.</p>
      </li>
      <li>
        <p>В контексте: кодировку можно
          вывести из контекста в котором встречается последовательность байтов. 
          Например, браузеры обычно отправляют данные формы в кодировке символов,
          которую использует страница, содержащая эту форму. Это очень слабая форма
          спецификации так как последовательность байтов часто передается с 
          контекста, например, в log файлы, где кодирование уже нельзя
          изменить. Кроме того, пользователи иногда меняют кодировки браузера так, что
          кодироване данных формы, которое возвращается не будет соответствовать кодировке
          страницы, созданной веб-приложением. Использование UTF-8 является одним из способов
          свести к минимуму ущерб от этой слабой формы спецификации  
          кодирования так как устраняет необходимость пользователям изменять
          кодировку браузера и поэтому для UTF-8 обнаружение кодировки работает лучше
          чем для большинства других кодировок. </p>
      </li>
      <li>За внешним соглашением: Когда ничего из вышеперечисленного не применяется,
        такое как текстовые файлы, то надо сделать внешнее соглашение о
        кодировании. Такое соглашение могло бы, например, быть частью лицензионного 
        соглашения для ленты контента. Первые четыре механизма лучше, чем 
        два последних и им следует отдавать предпочтение везде, где это возможно. Лучше  
        использовать любой из них, чем вообще не указывать кодировку.</li>
    </ul>
  </section>
  <section>
    <h3 id="encodingnames"><a href="#encodingnames">Названия кодировок 
      символов</a></h3>
    <p>Существует стандарт для названий кодировок в интернете, <a
class="print" href="http://www.ietf.org/rfc/rfc2978.txt">RFC 2978</a>, и связанный <a
class="print" href="http://www.iana.org/assignments/character-sets">реестр IANA 
      charset</a>. Однако фактическое использование часто отличается. Многие кодировок приходят в
      различных вариантах или имеют сестринские кодирования, которые поддерживают расширенные наборы символов, и
      различное программное обеспечение, часто использует разные названия для одного и того же кодирования или
      то же название для разных кодировок. Например, название ISO-8859-1 часто используется для описания данных, которые в действительности используют кодировку windows-1252. Это последнее кодирование (Microsoft Windows code page 1252) очень похоже на кодировку ISO 8859-1, но назначает графические символы до диапазона байтов между 0x80 и 0x9F. Многие веб-приложений (таких как браузеры, поисковые системы, и т.д.) относятся к контенту который отмеченный, как ISO 8859-1, как к такому, что использует кодирование windows-1252 потому, что для всех практических целей, windows-1252 является &quot;расширением&quot; ISO 8859-1. Другие приложения, такие как преобразователи кодирования (например iconv или ICU) достаточно буквальные и вы должны указать правильное название кодировки, чтобы получить правильные результаты.</p>
  </section>
  <section>
    <h3 id="determination"><a href="#determination">Определение кодировки 
      символов</a></h3>
    <p>Всякий раз, когда последовательность байтов интерпретируется как текст и обрабатывается, ее 
      кодирование должен быть известным. Во многих случаях определение кодировки
      символов настолько тривиальное, что об этом даже не задумываются - например, когда 
      обрабатывается строка в языке программирования, который указывает, что строки 
      закодованни в UTF-16. Однако в других случаях, нет четкой спецификации
      доступно ли кодирование или текст, приходит от источника, которому нельзя 
      полностью доверять, чтобы обеспечить правильную спецификацию. В таких случаях 
      более сложный процесс, требует определения кодировки символов и 
      позднее нужно включить исправление допущенных ошибок: </p>
    <ul>
      <li>Интерпретировать любые доступные спецификации кодирования. Если
        спецификация доступна и ей можно доверять, то все готово.</li>
      <li>Если спецификация кодирования символов доступна, но ей
        полностью нельзя доверять, то проверьте ее. Проверка доступна для кодировок,
        которые накладывают ограничения на действительные последовательности байтов, такие как UTF-8, EUC-KR,
        ISO 2022-JP. Если текст превращен в другую кодировку для
        внутренней отделки, проверка часто является просто побочным эффектом 
        преобразования, но если преобразование не требуется, то необходимо сделать
        проверку. Если последовательность байтов недопустима для указанного кодирования вам
        необходимо отказаться от входной информации и связаться с провайдером, чтобы он предоставил правильную входную информацию (в
        случае XML, отказ необходим согласно спецификации). Тем не менее, в
        случаях, когда у вас нет контроля над данными, переходите к следующему
        шагу.</li>
      <li>Если спецификация кодирования символов не доступна, или 
        не удалось провести проверку используйте выявление кодировки для определения вероятного
        кодирования.</li>
      <li>Если кодирование было определено путем выявления
        (а не по спецификации и проверке), то держите неподалеку оригинальную
        последовательность байтов, для того чтобы позже можно было снова превратить его  
        на другое кодирование символов. Обеспечьте механизм пользовательского интерфейса, который позволяет пользователям
        переопределить заданное или обнаруженое кодирование и повторить 
        преобразования. Сохраните вместе с последовательностью байтов кодировки символов, которое чаще всего  
        используются для последовательности байтов, особенно, если это было выбором 
        пользователя, это поможет избежать ненужной переработки всех вышеупомянутых шагов.</li>
    </ul>
  </section>
  <section>
    <h3 id="selection"><a href="#selection">Выбор и назначение кодировки символов</a></h3>
    <p>При отправке текста, выбор кодировки символов должен базироваться на основе формата данных и получателя. Раздел <a href="#externalif">Принятие Решения об Использовании Кодировки Символов для Внешних Интерфейсов</a> обсуждает использование кодирования на основе форматов данных. В большинстве случаев рекомендуется Unicode кодирование. Однако, есть два основных исключения: </p>
    <ul>
      <li>
        <p><em>Электронная почта</em>: Многие старые приложения электронной почты не поддерживают UTF-8. В настоящее время, электронная почта должна превращаться в устаревшее кодувание, которое может представить весь ее контент; UTF-8 следует использовать только тогда, когда невозможно найти такое устаревшее кодирования.</p>
      </li>
      <li>
        <p><em>Мобильные браузеры</em>: Мобильные системы не всегда поддерживают UTF-8. Поэтому возможно необходимо будет выбрать другие кодирования на основе конкретного устройства. </p>
      </li>
    </ul>
    <p>Независимо от того, какое кодирование используется, кодировку однозначно надо указывать, используя один из механизмов, описанных в разделе <a href="#encodingspecs">Спецификации Кодировок Символов</a>. </p>
  </section>
  <section>
    <h3 id="ceconversion"><a href="#ceconversion">Преобразование кодировки символов</a></h3>
    <p>Перекодировка нужна всегда, когда текст ожидается в одной кодировке символов в одном месте и в другой кодировке символов в следующем месте. ICU и iconv - часто используемые библиотеки для преобразования кодировки символов, однако, некоторые платформы, такие как Java и Perl, предоставляют свои библиотеки преобразования.</p>
    <p>При использовании библиотек, важно использовать правильные названия кодировки для конкретной библиотеки. Для более подробной информации смотрите раздел <a href="#encodingnames">Названия Кодировок Символов</a>.</p>
    <p>Есть некоторые конкретные вопросы преобразования, которые могут повлиять на определенные
      продукты:</p>
    <ul>
      <li>Альтернативные отображения некоторых символов: в некоторых Восточно-азиатских
        кодировках, некоторые символов имеют несколько толкований. Например,
        значение 0x5C в Shift-JIS может быть истолковано в именах файлов как "\", но
        в финансовых данных как "¥". При отображении Unicode, должно быть принято
        решение отражать или U+005C "\" или U+00A5 "¥". Общий подход - 
        отображать U+005C, работающий в файловой системе и который много Японских
        шрифтов будут отображать как  "¥". Однако, если поведение вашей программы
        зависит от отображения (например, она анализирует значение валюты), вы имеете 
        принять необходимые меры, чтобы контролировать результат. В случае примера,
        вы могли бы перед превращением отобразить 0x5C как код валюты "JPY" и
        затем, после преобразования "JPY" как U+00A5.</li>
      <li>
        <p>Символы частного использования: Несколько
          кодировок, включая Unicode и большинство кодировок Восточной Азии, 
          имеют диапазоны code point (точка кода), которые зарезервированы для частного использования или просто
          не определены. Они часто используются для символов конкретного или частного  
          использования — <a class="print" href="http://en.wikipedia.org/wiki/Emoji">emoji</a> установленая ​​Японскими операторами мобильной связи является примером. Стандартные преобразователи
          символов не знают как отобразить такие символы. Для приложений, где
          поддержка символов частного использования является критической, чтобы обеспечить правильное отображение вам лучше 
          использовать обычные преобразователи символов или использовать обходные пути, такие как numeric character
          references (числовые ссылки).</p>
      </li>
      <li>
        <p>Версии кодировок символов и 
          отображений: Много кодировок символов менялись с течением времени, и поэтому
          сопоставьте их. Примером может служить отображение с <a
    class="print" href="http://en.wikipedia.org/wiki/HKSCS">HKSCS</a> в Unicode: Ранние
          версии HKSCS имели отображать числовые символы в области частного использования Unicode,
          ибо Unicode не поддерживал их, но позже эти 
          символы добавили в набор символов Unicode, и
          отображение с HKSCS были изменены, чтобы отобразить новые добавленые символы. 
          Вообще, вы должны убедиться, что вы используете последние версии
          преобразователей символов.</p>
      </li>
    </ul>
  </section>
  <section>
    <h3 id="normalization"><a href="#normalization">Нормализация</a></h3>
    <p>В Unicode некоторые символы можно представить более чем одним способом.
      Unicode определяет несколько путей устранения этих различий, когда они
      не имеют значения для обработки текста. Дополнительные сведения о нормализации, смотрите <a
class="print" href="http://www.w3.org/TR/charmod-norm">CharMod-Norm</a>. </p>
    <p>Unicode не предписывает, когда использовать конкретную форму Unicode
      нормализации. Тем не менее, целый ряд процессов, работает лучше, если текст нормирован, в
      отдельных процессах, которые содержат в себе сравнения текста, таких как сортировка, поиск и
      обработка regular expression (регулярное выражение). Некоторые библиотеки выполняя эти процессы
      предлагают нормализацию в качестве части процесса, в противном случае, прежде чем использовать
      эти процессы вы должны убедиться, что текст нормирован. Как правило, нормализационная
      форма C (NFC) рекомендована для веб-приложений. Тем не менее, некоторые процессы,
      такие как интернационализированные доменные имена, используют другие нормализационное формы.</p>
    <p>Некоторые языки требуют нормализации перед обработкой, поскольку
      различные методы ввода могут генерировать различные последовательности codepoints (точка кода)
      Unicode. Вьетнамская язык является ярким примером, где вьетнамская раскладка клавиатуры
      начиная с Windows 2000 и выше производит последовательности символов, которые отличаются от, тех
      что производят большинство Вьетнамского программного обеспечения для ввода данных. Аналогичные вопросы возникают
      в ряде Африканских языков, первая, которая приходит в голову -  
      Йоруба.</p>
  </section>
  <section>
    <h3 id="textsize"><a href="#textsize">Вопросы о размере текста</a></h3>
    <p>Сохранение текста в Unicode часто занимает больше места, чем сохранение его в устаревших
      кодировках. Точное значение занятого пространства зависит от языка и конкретного текста. Пространство для некоторых распространенных кодировок может быть:</p>
    <table>
      <tbody>
        <tr>
          <td><p><strong>Источник Кодирования</strong> </p></td>
          <td><p><strong>Языки</strong> </p></td>
          <td><p><strong>UTF-8</strong> </p></td>
          <td><p><strong>UTF-16</strong> </p></td>
        </tr>
        <tr>
          <td>ASCII </td>
          <td>Английский, Малайский, ... </td>
          <td>0% </td>
          <td>100% </td>
        </tr>
        <tr>
          <td>ISO-8859-1</td>
          <td>Западноевропейские </td>
          <td>10% </td>
          <td>100% </td>
        </tr>
        <tr>
          <td>ISO-8859-7, обычный текст </td>
          <td>Греческий </td>
          <td>90% </td>
          <td>100% </td>
        </tr>
        <tr>
          <td>ISO-8859-7, 50% разметка </td>
          <td>Греческий </td>
          <td>45% </td>
          <td>100% </td>
        </tr>
        <tr>
          <td>TIS-620, обычный текст </td>
          <td>Тайский </td>
          <td>190% </td>
          <td>100% </td>
        </tr>
        <tr>
          <td>TIS-620, 50% разметка </td>
          <td>Тайский </td>
          <td>95% </td>
          <td>100% </td>
        </tr>
        <tr>
          <td>EUC-KR, обычный текст </td>
          <td>Корейский </td>
          <td>50% </td>
          <td>5% </td>
        </tr>
        <tr>
          <td>EUC-KR, 50% разметка </td>
          <td>Корейский </td>
          <td>25% </td>
          <td>55% </td>
        </tr>
      </tbody>
    </table>
    <p>На макроуровне это действительно не имеет большого значения. В настоящее время пропускная 
      способность и вместилище сети заняты видео, изображением и звуковыми файлами, а текст
      потребляет только долю. Там может быть влияние на системы хранения данных,
      которые сохраняют только текст. Если вас действительно волнует размер текста, то его можно уменьшить 
      используя сжатие.</p>
    <p>Однако на микроуровне, увеличение размера вместилища имеет ряд
      последствий:</p>
    <ul>
      <li>Алгоритмы, разработанные под допущения одного символа,
        одного байта, больше не работают даже для Европейских языков (они никогда не 
        работали для Восточно-азиатских языков). Их нужно изменить, чтобы приспособить
        многобайтовое отображение символов. Убедитесь, что вся обработка
        всегда работает с полными символами. Полный символ может занять 
        от одного до четырех байт в кодировке UTF-8, и одну или две единицы 16-битного кода
        в UTF-16. Для позиций символа, всегда используйте индекс
        first byte (первого байта) или code unit(элемент кода) символа.</li>
      <li>Обычно, спецификации любой длины нужно пересмотреть для того, чтобы
        убедиться, что они будут базироваться на основе байтов, символов, UTF-16 
        code units (элемент кода), или глифов. Каждая основа имеет смысл в некоторых ситуациях, но
        должно быть ясно, какая из них применяется. Использование основанного на символах определения
        гарантирует достаточно места, но может занять больше места, чем необходимо, 
        так как каждый символ теперь требует 4 байта. Использование
        основанного на байтах определения позволяет избежать такого размера, но может значительно ограничить
        количество символов. Лучшими, конечно, есть схемы, которые выделяют
        достаточно места для хранения данного текста. Другие приложения, управляющие пространством
        (например, несколько "символов", которые могут отображаться в поле формы)
        могут не иметь возможности что-то сделать с несколькими логическими символами, а вместо этого 
        необходимо подсчитать количество единиц визуального текста (так называемые графемы).</li>
      <li>Размер текста изменяется при каждом его преобразовании из одного
        кодирования в другое. Нет фиксированных коэффициентов, применимых
        для оценки размера необходимого вместилища, так что единственный способ узнать это -
        действительности превратить текст. Необходимо соблюдать осторожность, чтобы избежать сокращения. Если
        сокращение на самом деле необходимо, как и в некоторых отображаемых контекстах, особое внимание
        надо обратить на сокращение границ символа или графемы.</li>
    </ul>
  </section>
  <section>
    <h3 id="libraries"><a href="#libraries">Использование 
      библиотек</a></h3>
    <p>Для работы с Unicode, часто выгоднее использовать программные библиотеки
      , которые предназначены для поддержки Unicode. Старые библиотеки могут не так хорошо поддерживать Unicode
      , или вообще не поддерживать.</p>
  </section>
  <section>
    <h3 id="language"><a href="#language">Определение и 
      назначение языка</a></h3>
    <p>Хотя Unicode позволяет многоязычные программы и документы, есть
      много процессов, которые требуют знания об использовании фактического языка. Такие 
      процессы варьируются от простого сложения к поиску и проверке
      правописания.</p>
    <p>APIs, базирующиеся на основе Unicode должны позволять спецификацию  
      языка (языков), что используется там где только такие знания могут пригодиться и язык
      контента созданного пользователями должен быть записан там где это возможно. 
      Там где нельзя определить язык в ресурсе, может потребоваться библиотека определения 
      языка.</p>
    <p>Чтобы помочь другим программам, язык веб-контента,
      нужно назначать с использованием HTTP заголовка <code class="kw" translate="no">Content-Language</code> или HTML/XML атрибутов <code class="kw" translate="no">lang</code>.</p>
  </section>
  <section>
    <h3 id="fonts"><a href="#fonts">Вопросы по шрифтам</a></h3>
    <p>При задании шрифтов веб сайты, использующие Unicode должны быть более осторожны
      чем веб сайты, использующие устаревшие кодировки. Многие языки имеют уникальные или специфические
      письменные традиции, даже если они разделяют скрипт с другими языками. В
      других случаях, поддержка шрифтов может быть препятствием, так как шрифты необходимые для
      отображения определенных скриптов не установлены на большинстве систем.</p>
    <p>Например, Китайские и Японские системы письма имеют большое количество
      символов, но имеют различные печатные традиции, так что Китайские 
      шрифты, как правило, не приемлемы для текста на Японском языке, и наоборот. 
      Например, есть тот самый символ, отображаемый при помощи Китайского и 
      Японского шрифта (вместе с HTML кодом, который используется для создания снимка
      экрана):</p>
    <div class="example">
      <p><img src="index-data/zhs-jpn-font.jpg" height="53" width="105"
alt="Изображение того же идеографического символа Unicode, но с двумя разными представлениями глифов."
/></p>
      <p><code>&lt;span style="font-size:3em;font-family:sans-serif;"&gt;<br />
        &lt;span lang="zh-Hans-CN" style="font-family: simsun, hei,
        sans-serif;"&gt;з›直&lt;/span&gt;<br />
        &lt;span lang="ja" style="font-family: 'ms gothic',
        osaka;"&gt;з›直&lt;/span&gt;<br />
        &lt;/span&gt;</code></p>
    </div>
    <p>Когда используются устаревшие кодировки браузеры часто угадывают язык с
      кодирования и выбирают соответствующий шрифт.</p>
    <p>Поскольку Unicode поддерживает как Китайский так и Японский языки, этот прием не работает 
      для страниц, закодированных в Unicode, а результатом может быть неуместный шрифт или
      даже безобразное сочетание шрифтов, используемых для отображения контента.</p>
    <p>Одно из решений - следить за языком, который используется, и 
      передать браузеру язык и шрифты, используемые для 
      языка. Для одноязычных страниц простой и эффективный подход - использование для языка 
      специальной таблицы стилей. Для многоязычных страниц, вы должны использовать
      атрибут <code class="kw" translate="no">lang</code> HTML тэгов для определения языка; несколько браузеров
      используют эту информацию для выбора правильного шрифта. Для точного
      контроля над шрифтом вы также можете использовать классы для определения языка и
      класс селекторов в таблице стилей, чтобы установить шрифт. CSS 2.1 селекторы
      псевдо класса языка, которые будут выбирать непосредственно на основе атрибута(ов) 
      языка, не поддерживаются Internet Explorer и поэтому имеют ограниченную полезность.
      Смотрите <a 
class="print" href="http://www.w3.org/International/tests/results/css-lang">Результаты тестирования: Зависимый от языка стайлинг</a>.</p>
  </section>
</section>
<section>
  <h2 id="migrating"><a href="#migrating">Перенос данных</a></h2>
  <p>Преобразование данных, связанных с продуктом, во многих случаях может быть 
    самой большой проблемой в переходе продукта в Unicode. Например, некоторые
    программы владеют или имеют доступ к ряду баз данных, некоторые из которых управляются
    такими движками баз данных как Oracle или MySQL. Другие используют собственные форматы
    файла и механизмы доступа. Эти базы данных, независимо от типа необходимо 
    перенести для поддержки Unicode.</p>
  <p>При переносе данных в Unicode хорошо бы объединить
    базы данных, которые были раньше отдельными через различные 
    кодировки. Использование единой базы данных по всему миру или только нескольких для
    основных регионов может упростить развертывание и обслуживание, и может позволить
    обмен контентом между различными рынками, и Unicode идеально подходит для этого поскольку он
    может представлять текст на всех языках. Однако при объединении вы должны иметь в виду,
    что другие ограничения связаные с распределением контента могут оставаться: 
    доступность языка, условия лицензирования, а также юридические или культурные
    ограничения на публикацию материалов, связанных с политикой, религией, полом и
    насилием.</p>
  <p>Стратегии для преобразования данных будут изменяться в зависимости от ряда
    факторов:</p>
  <ul>
    <li>Все ли данные в базе данных используют то же самое кодирование, или разные 
      кодирования.</li>
    <li>Известно кодирования данных или нет.</li>
    <li>Зависит ли от знаний о кодировке доступ к данным или 
      другие функции, реализованные в базе данных, или нет. Например, 
      индексы на текстовых полях в целом зависят от кодировки символов и
      языка, в то время как индексы на числовых полях не зависят.</li>
    <li>Размер данных.</li>
    <li>Репликация данных.</li>
    <li>Uptime (безотказная работа) требования.</li>
  </ul>
  <p>Через вариации в этих факторах не существует простого рецепта, которого 
    необходимо соблюдать при преобразовании базы данных продукта. Ниже 
    обсуждение общих соображений; однако, как правило, необходимо 
    создать план конверсии с учетом для каждого продукта. Такой план,
    скорее всего, будет иметь несколько фаз для анализа и преобразования с проверкой
    результатов преобразования, и восстановлением, если что пойдет не так.</p>
  <section>
    <h3 id="sizeissues"><a href="#sizeissues">Решение вопросов относительно 
      размера текста</a></h3>
    <p>Как уже упоминалось в <a href="#textsize">Вопросы относительно Размера Текста</a> (выше),
      преобразование текста в Unicode, как правило, происходит за требований расширенного
      вместилища, и вы должны тщательно рассмотреть вопрос о целесообразности измерения
      длины текста в байтах, символах или UTF-16 code units (элементы кода). Чтобы уменьшить влияние
      увеличенных размеров поля переключите CHAR поля в базах данных SQL
      на VARCHAR, что позволит базе данных выделить столько
      пространства сколько необходимо.</p>
    <p>При измерении текста, некоторые базы данных не дают вам выбора. Например,
      MySQL всегда измеряет с точки зрения Unicode BMP символов, в результате чего получается 3
      байта на символ. Другие, такие как Oracle, позволяют выбирать между семантикой символа
      или байта. Другие системы хранения данных, которые накладывают ограничения на размер скорее всего
      измеряют в байтах.</p>
    <p>При переносе, которое включает в себя перекодировку, будьте осторожны, чтобы 
      избежать сокращения. В некоторых случаях, к сожалению, вы не сможете это сделать,
      через такие внешние ограничения, как 30 байтный лимит в Oracle для
      схемы имен объектов в словарях данных (использование символов ASCII для схемы
      имен помогает избежать этой проблемы). В таких случаях, по крайней мере убедитесь, в сокращении
      в пределах символа.</p>
    <p>Кроме того: обратите внимание, что может быть расширение текста за счет перевода. Смотрите <a
class="print" href="/International/articles/article-text-size">Размер текста в переводе</a>.</p>
  </section>
  <section>
    <h3 id="asciidata"><a href="#asciidata">Выявление ASCII 
      данных</a></h3>
    <p>Следует определить наборы данных (файлы, таблицы базы данных, столбики базы данных),
      которые полностью закодированы в ASCII. Если требуется Unicode кодирования -
      UTF-8, то для таких наборов данных преобразования не требуется, поскольку последовательности
      байтов ASCII идентичны соответствующим последовательностям байтов UTF-8. Кроме того,
      индексы над ASCII текстовыми полями справедливы и для соответствующих UTF-8 или
      UTF-16 текстовых полей, если только они не основаны на порядке сортировки чувствительном к языку.
      Тем не менее, вы должны быть строгими в определении ASCII наборов данных. Термин
      "ASCII" часто ошибочно используется для таких вещей, которые не являются ASCII, такие как обычный
      текст (в любой кодировке) или текст в таких кодировках, как ISO 8859-1 или 
      Windows-1252. Кроме того, ряд кодировок был разработан, чтобы вписаться в
      7-битные последовательности байтов, представляя совершенно разные наборы символов 
      из ASCII.</p>
    <p>Чтобы убедиться, что набор данных действительно находится в ASCII, проверьте
      следующее:</p>
    <ul>
      <li>Все значения байтов в наборе данных находятся в диапазоне от 0x00 до 0x7F.
        ASCII не использует значения байтов выше за 0x7F.</li>
      <li>
        <p>Не используются такие значения байтов, как 0x0E, 0x0F, и 0x1B.
          Присутствие этих значений байтов, скорее всего, указывает, что данные
          действительности закодированы в <a class="print" href="http://en.wikipedia.org/wiki/ISO_2022">кодировке
          ISO-2022</a>.</p>
      </li>
      <li>
        <p>Если символы "+" и "-" встречаются, то промежуточные 
          байты не действительны для BASE-64. Если они есть, то не исключено, что
          текст закодирован в <a class="print" href="http://en.wikipedia.org/wiki/UTF-7"> кодировке 
          UTF-7</a>. Обратите внимание, что UTF-7 по возможности надо избегать 
          через потенциальную угрозу XSS атак.</p>
      </li>
      <li>
        <p>Такие последовательности символов, как "~{" и "~}" не встречаются.
          Если вы их встретили, то текст, вероятно, закодированный в <a
    class="print" href="http://en.wikipedia.org/wiki/HZ_%28character_encoding%29">кодировке
          HZ</a>.</p>
      </li>
    </ul>
  </section>
  <section>
    <h3 id="uncertainty"><a href="#uncertainty">Действия в условиях
      неопределенности</a></h3>
    <p>Как упоминалось ранее, иногда случается, что базы данных содержат текст
      кодирование которого не известно. Выявление кодировки можно использовать
      для получения представления о кодировании, но этот процесс не является надежным. Чтобы справиться с
      неопределенностью, необходимо выполнить ряд дополнительных шагов:</p>
    <ul>
      <li>Выполнить попытку для оценки точности определения кодировки. Используйте
        алгоритм обнаружения, который вы собираетесь использовать на подмножество данных, 
        преобразуйте данные из обнаруженного кодирования в Unicode, и для проверки результатов 
        нужны люди, которые знакомы с языками, которые использовались. Если точность
        не соответствует требованиям, попробуйте другие алгоритмы определения кодировки или 
        используйте дополнительную информацию, которая доступна для вашей программы.</li>
      <li>Если ваши данные содержат информацию связанную с кодированием (но вы
        не полностью ей доверяете), сосредоточьте внимание на случаях, когда алгоритм обнаружения
        распознает различные кодировки. Это может помочь вам сосредоточиться на необходимых 
        улучшениях в использовании дополнительной информации.</li>
      <li>После переноса обеспечьте способы для позднего исправления кодировки.  
        Одно из решений заключается в обеспечении пользовательского интерфейса, который позволяет пользователю
        указывать фактическое кодирование, которое затем сохраняется с текстом и используется
        для преобразования текста. Для этого вам нужно сохранить доступными оригинальные
        последовательности байтов, наряду с именем обнаруженного кодирования.
        Независимо от того, сохранение версии текста в Unicode определяется тем, насколько часто
        текст доступен - для текста, к которому обращаются часто, возможно нужно будет
        caching (кэшировать) Unicode версию, а для другого текста возможно
        лучше сохранить вместилище и регенерировать Unicode версию
        когда это необходимо. </li>
    </ul>
    <p>Для простоты, следующие разделы предусматривают, что кодирование может быть 
      точно определено и, следовательно, преобразование является одноразовым мероприятием. Там где
      это не так, стратегии должны быть скорректированы.</p>
  </section>
  <section>
    <h3 id="ncrs"><a href="#ncrs">Значение Numeric Character References 
      (Числовых Ссылок)</a></h3>
    <p>Базы данных сохраняя созданный пользователями контент, часто содержат числовые ссылки
      (NCRs) на введенные пользователями символы отличные от ASCII такие, как
      "&amp;#x0152;" (Œ) или &quot;&amp;#x20AC;&quot; (€). Многие браузеры создают NCRs тогда, когда
      пользователи вводят текст в поля формы, которые не могут быть выражены в
      кодировке символов формы. NCRs отлично работают, если текст впоследствии перепоказаний в 
      HTML. Однако, для других процессов, они не работают потому, что они не совпадают
      с текстом, который они представляют в поиске, они сортируются в неправильном месте, или
      они игнорируются при преобразовании. При переходе на Unicode также
      было бы хорошо превратить NCRs в соответствующие символы Unicode. Однако, вы должны быть
      осторожны, чтобы избежать преобразований, которые меняют значения
      текста (преобразование из "&amp;amp;" в "&amp;") или преобразования в
      текст который будет отфильтрован по соображениям безопасности.</p>
  </section>
  <section>
    <h3 id="bom"><a href="#bom">Использование BOM (маркер порядка байтов)</a></h3>
    <p>При переходе из устаревших кодировок в Unicode, принято использовать
      устаревшие кодировки и Unicode параллельно, и вы должны
      их различать. В общем случае, это требует спецификаций
      кодировки. Однако, если вам нужно отличить только одно 
      определенное устаревшее кодирование (например, старую кодировку сайта по умолчанию) и UTF-8,
      Вы можете использовать Unicode Маркер Порядка Байтов (BOM) в качестве префикса для идентификации
      строк UTF-8. Это особенно удобно, если нет оговорки о спецификации
      кодировки, например, в обычных текстовых файлах или в cookies (куки). 
      BOM в UTF-8 - последовательность байтов 0xEF 0xBB 0xBF, которая вряд ли понадобилась бы
      в любой устаревшей кодировке.</p>
    <p>Считыватель данных, который идентифицирует их кодирование, таким образом, для определения 
      кодирования читает первые три байта. Если байты соответствуют BOM, то три
      байта зачищаются и оставшийся контент возвращается как UTF-8. Если байты
      не соответствуют BOM, то весь контент превращается из устаревшего кодирования в UTF-8. Однако, эта зачистка не является автоматической, и это влияет на некоторые платформы или языки. Например, PHP файл, который начинается с BOM будет истолкован неправильно PHP процессором. Так что этот трюк лучше ограничить и использовать для известных частей вашего сайта или кода.</p>
  </section>
  <section>
    <h3 id="plaintext"><a href="#plaintext">Преобразование текстовых
      файлов</a></h3>
    <p>Обычные текстовые файлы, которые используют одну кодировку легко превратить.
      Например, инструмент iconv доступен на большинстве систем основанных на Unix/Linux. В
      системах, которые не имеют его, удобно установить Java
      Development Kit и использовать его инструмент native2ascii:</p>
    <div class="example"> <code>native2ascii -encoding _''sourceencoding'' ''sourcefile'' |
      native2ascii -reverse -encoding ''targetencoding'' &gt;
      ''targetfile''</code></div>
    <p>Для небольшого количества файлов, также можно использовать редакторы: TextPad на Windows,
      TextEdit на Mac, или jEdit на любой платформе, есть лишь несколько редакторов, которые могут
      преобразовывать файлы. Заметим, что некоторые редакторы такие, как Notepad (Блокнот), любят
      приставлять Unicode byte-order mark (BOM) спереди Unicode файлов, что в случае
      UTF-8 файлов не являются необходимыми и могут вызвать проблемы с программным обеспечением, при
      чтении файлов.</p>
  </section>
  <section>
    <h3 id="structured"><a href="#structured">Преобразование 
      структурированных файлов</a></h3>
    <p>Структурированные файлы в данном контексте - любые файлы, кроме баз данных SQL,
      имеющие компоненты, которые могут иметь различные кодировки или что 
      имеют ограниченную длину. Примеры: log files (файлы журнала), в которых различные записи могут
      использовать различные кодировки; сообщение электронной почты, где разные заголовки и MIME 
      компоненты могут использовать различные кодировки, и заголовки имеют ограниченную
      длину; и cookies (куки), которые часто рассматриваются, как имеющие несколько полей.
      Для таких файлов, каждый компонент должен быть преобразован отдельно, и ограничения
      длины должны рассматриваться отдельно для каждого компонента.</p>
  </section>
  <section>
    <h3 id="sql"><a href="#sql">Преобразование баз данных SQL</a></h3>
    <p>База данных SQL на самом деле состоит из двух компонентов: компонент сервера,
      который фактически управляет данными, а также клиентский компонент, который взаимодействует
      с другими приложениями (например, PHP или Java runtime) и взаимодействует с
      компонентами сервера. Кодирование, которое клиент использует для связи с
      сервером можно установить отдельно от кодирования символов, которое использует
      сервер; сервер преобразует его в случае необходимости.</p>
    <p>В зависимости от размера базы данных и ее требований к безотказной работе, доступные 
      различные стратегии для преобразования:</p>
    <ul>
      <li>Дамп и перезагрузка: содержимое базы данных сбрасывается в текстовый
        файл, превращается в желаемое кодирование Unicode, и загружается в новую
        базу даних. Эта стратегия проста, но работает только для баз данных, которые можно
        перевести в автономный режим на длительный период, необходимый для преобразования.</li>
      <li>Создать новую базу данных Unicode: создается новая база данных, использующая  
        кодировку Unicode и поверх копируется контент из старой базы данных и с ходу
        делается преобразование. Транзакции, которые обновляют или удаляют контент, который уже 
        скопирован должны быть отражены в новой базе данных. Когда новая
        база данных настигает старую, доступ переключается для новой 
        базы данных. Как правило, это лучшая стратегия для производства баз данных, 
        но она требует доступности достаточного количества серверного оборудования баз данных для запуска 
        двух баз данных в параллельном режиме.</li>
      <li>Добавить Unicode столбцы: В этой модели, каждый текстовый столбец в 
        устаревшей кодировке спаренный с новым столбцом в Unicode кодировке. Поля
        в этого столбика заняты, а потом еще и меняются запросы для доступа к
        Unicode столбику вместо столбика устаревшего кодирования. Если устаревшее
        кодирование точно известно, то столбик устаревшего кодирования можно
        удалить. Эта стратегия может понадобиться, если на диске не хватает места для создания  
        абсолютно новой базы данных и, если код доступа к
        базе данных приемлемо мал.</li>
      <li>Преобразования на месте: Некоторые базы данных, такие как MySQL, имеют
        возможность на месте превратить таблицу с одной кодировки в другую. Это
        работает только для баз данных, которые можно перевести в автономный режим на период, необходимый
        для преобразования.</li>
      <li>Преобразование в месте с тэгом кодирования: Если база данных только
        управляет байтами, и все интерпретации байт как текста делаются
        за пределами базы данных, то можно делать преобразования на месте и
        отслеживать прогресс используя тэг кодирования на каждой записи. Процессы, которые
        имеют доступ к базе данных должны быть проинформированы о тэге кодирования и превращать
        байты, которые они хранят в базе данных или извлекать из базы данных с их и в их 
        собственные кодировки. Если база данных содержит только одно устаревшее кодирование,
        BOM можно использовать, чтобы отличить Unicode строки.</li>
    </ul>
    <p>Язык и документация SQL имеют дурную привычку использовать
      термин "character set" (набор символов) для кодировок символов, игнорируя тот, факт, что UTF-8
      и UTF-16 (и даже GB18030) являются разными кодировками одного и того же набора
      символов.</p>
    <div class="h4">
      <h4 id="oracle"><a href="#oracle">Особенности Oracle</a></h4>
      <p>Oracle имеет общую поддержку Unicode, начиная с 8-й версии,
        но поддержка дополнительных символов доступна только начиная с
        версии 9r2, и поддержка Unicode 3.2 только начиная с 10-й версии. Также до 9-й версии
        немного трудно использовать такие типы данных, как <code class="kw" translate="no">NCHAR</code> и <code class="kw" translate="no">NVARCHAR</code>. 
        Oracle обеспечивает всестороннюю поддержку Globalization Support Guides (Руководство Поддержки Глобализации) для таких
        версий: <a 
class="print" href="http://download-west.oracle.com/docs/cd/A91202_01/901_doc/server.901/a90236/toc.htm">9r1</a>, <a 
class="print" href="http://download-west.oracle.com/docs/cd/B10501_01/server.920/a96529/toc.htm">9r2</a>, <a 
class="print" href="http://download-west.oracle.com/docs/cd/B14117_01/server.101/b10749/toc.htm">10r1</a>,
        и <a 
class="print" href="http://download-west.oracle.com/docs/cd/B19306_01/server.102/b14225/toc.htm">10r2</a>.
        Особенно актуальны разделы по вопросам Character Set Migration (Переход) и
        Character Set Scanner (Сканер).</p>
    </div>
    <p>Кодирование символов избранное для базы данных Oracle устанавливается для
      всей базы данных, включая данные, схемы и запросы, с одним исключением: <code class="kw" translate="no">NCHAR</code> и <code class="kw" translate="no">NVARCHAR</code> типы
      всегда используют Unicode. Для базы данных предлагаются различные Unicode кодирования,
      как для целой базы так и для таких типов данных как <code class="kw" translate="no">NCHAR</code> и <code
class="kw" translate="no">NVARCHAR</code>. Для базы данных правильными являются
      UTF-8 под названием <code class="kw" translate="no">AL32UTF8</code>, и вариант <code
class="kw" translate="no">UTF8</code>, кодирующий дополнительные символы в виде двух 3-байтных
      последовательностей. Для перехода баз данных в Unicode, вы должны использовать <code
class="kw" translate="no">AL32UTF8</code>(базы данных, которые уже используют <code
class="kw" translate="no">UTF8</code> в большинстве случаев могут продолжают это делать - разница
      между этими кодировками может повлиять на параметры сортировки и индексации в
      базе данных, но в целом это не имеет большого значения, так как клиентский интерфейс
      превращает <code class="kw" translate="no">UTF8</code> чтобы исправить UTF-8). Для таких типов данных, как <code
class="kw" translate="no">NCHAR</code> и <code class="kw" translate="no">NVARCHAR</code> UTF-16 доступен под названием <code class="kw" translate="no">AL32UTF8</code>, рядом
      с вариантом кодирования <code class="kw" translate="no">UTF8</code>. Семантику
      спецификаций длины для таких типов данных, как <code class="kw" translate="no">CHAR</code>, <code
class="kw" translate="no">VARCHAR2</code>, и <code class="kw" translate="no">LONG</code> можно
      установить используя <code class="kw" translate="no">NLS_LENGTH_SEMANTICS</code>, с
      байтовой семантикой по умолчанию, в то время, как типы данных <code class="kw" translate="no">NCHAR</code> и <code
class="kw" translate="no">NVARCHAR</code> всегда используют символьную семантику.</p>
    <p>Для правильного преобразования между кодированием (ямы), что используется в пределах базы данных в
      кодировке клиента очень важно определить <code
class="kw" translate="no">NLS_LANG</code> переменную среду на стороне клиента. Эта
      переменная описывает язык, территорию, и кодирования, что используется клиентской
      операционной системой. Oracle имеет множество других параметров, чтобы указать в базе данных чувствительное к
      локали поведение; они вообще могут быть установлены отдельно от кодировки
      до тех пор пока кодирование может представлять символы выбранной локали.
      Unicode поддерживает все языковые стандарты (локали).</p>
    <p>Oracle обеспечивает встроенную поддержку для нескольких стратегий преобразования.
      Инструмент Character Set Scanner помогает в выявлении возможного преобразования и
      сокращении проблем в анализе предварительного преобразования. Утилиты экспорта и импорта
      помогают в выполнении дампа и перезагрузке стратегии. Добавлять Unicode
      столбики легко, так как <code class="kw" translate="no">NCHAR</code> и <code
class="kw" translate="no">NVARCHAR</code> типы данных поддерживают Unicode независимо от
      кодировки базы данных. Преобразования на месте с тэгом кодирования возможно, если
      сама база данных не растолкует текст - <code class="kw" translate="no">ALTER
      DATABASE CHARSET</code> заявление может быть использовано для того, чтобы информировать базу данных о
      фактическом кодировании когда преобразование будет завершено.</p>
    <p>Есть сообщения, что <code class="kw" translate="no">NCHAR</code> типы данных <a
class="print" href="http://download-west.oracle.com/otndocs/tech/ias/portal/files/RG/complete_web_site_php_faq2.htm#nchar">не
      поддерживаются</a> в PHP Oracle Call Interface.</p>
    <div class="h4">
      <h4 id="mysql"><a href="#mysql">Особенности MySQL</a></h4>
      <p>Чтобы получить поддержку Unicode в базах данных MySQL, вы должны использовать
        версию MySQL 4.1 или выше. Для получения информации о переходе на эту версию и
        о возможных проблемах совместимости смотрите <a 
class="print" href="http://dev.mysql.com/doc/refman/4.1/en/charset-upgrading.html">Обновление
        Character Sets с MySQL 4.0</a>. Подробную информацию о поддержке
        кодировки символов в MySQL, смотрите в разделе документации MySQL <a 
class="print" href="http://dev.mysql.com/doc/refman/4.1/en/charset.html">Поддержка Character 
        Set</a>. Кодирование символов  
        для <a 
class="print" href="http://dev.mysql.com/doc/refman/4.1/en/charset-syntax.html">контента базы
        данных</a> можно установить отдельно на уровне сервера, базы данных, таблицы или
        столбца. Если кодирование явно не задано, то оно наследуется от следующего
        более высокого уровня.</p>
    </div>
    <p>Кодированием по умолчанию в MySQL есть <code class="kw" translate="no">latin1</code>, а именно, ISO-8859-1. Unicode кодирования, 
      которые поддерживаются называются <code class="kw" translate="no">utf8</code> и <code class="kw" translate="no">ucs2</code>. Обычно рекомендованным
      кодированием для MySQL должно быть <code class="kw" translate="no">utf8</code>. Оба <code class="kw" translate="no">utf8</code> и <code class="kw" translate="no">ucs2</code> ограничены для
      символов Unicode Basic Multilingual Plane (BMP), так что нет
      никакой поддержки для дополнительных символов в MySQL. В результате <code class="kw" translate="no">utf8</code> не является
      полностью совместимой реализацией UTF-8 (хотя для большинства случаев это
      нормально). Такие типы данных, как <code class="kw" translate="no">NCHAR</code> и <code class="kw" translate="no">NVARCHAR</code> всегда используют <code class="kw" translate="no">utf8</code>.</p>
    <p>Спецификации длины для символьных типов данных
      интерпретированы в Unicode BMP символы, так спецификация <code>CHAR(5) CHARACTER SET utf8</code> зарезервирует 15 байт. Такие meta данные
      как имена пользователей, всегда хранятся в UTF-8, поэтому нелатинские названия можно
      использовать. Кодирования символов для <a 
class="print" href="http://dev.mysql.com/doc/refman/4.1/en/charset-connection.html">клиентского
      подключения</a> можно установить отдельно для клиента, подключения, и результатов, но, чтобы
      избежать путаницы, лучше установить их все вместе, используя <code>SETВ NAMESВ 'utf8'</code>. Кодирование <code class="kw" translate="no">ucs2</code> не
      поддерживается для клиентских подключений, так что нет никаких оснований использовать это
      кодирование для контента базы данных.</p>
    <p>Сортировки, связанные с кодировками символов, поэтому они
      всегда должны устанавливаться в то же время, что и кодирование. Если <code class="kw" translate="no">utf8</code> используется без указания о сортировке, то по умолчанию используется такая сортировка, как <code
class="kw" translate="no">utf8_general_ci</code>. Это устаревший алгоритм
      сортировки, что не является хорошим для любого конкретного языка. Сортировка <code
class="kw" translate="no">utf8_unicode_ci</code> лучшая по умолчанию, так как она реализует
      Unicode Collation Algorithm (UCA) и работает для многих языков, специально
      не поддерживается названной сортировкой. Вы также можете выбрать одну из
      language-named UTF-8 сортировок, чтобы получить language-specific сортировку
      "строго" основанную на UCA. Смотрите список сортировок для <a 
class="print" href="http://dev.mysql.com/doc/refman/4.1/en/charset-unicode-sets.html">Unicode
      Character Sets</a>. MySQL поддерживает <a 
class="print" href="http://dev.mysql.com/doc/refman/4.1/en/charset-convert.html">функцию 
      CONVERT</a>, которая позволяет преобразовывать результаты запроса из одного
      кодирования в другое. MySQL также поддерживает преобразование на месте из одного
      кодирования в другое с помощью <a 
class="print" href="http://dev.mysql.com/doc/refman/4.1/en/alter-table.html">ALTER
      statement</a>: <code>ALTER TABLE table CONVERT TO CHARACTER SET
      utf8 COLLATE collation;</code>.</p>
    <div class="sidenoteGroup">
      <p>В некоторых случаях, кодирование столбика в схеме может быть неправильно
        назначенное - например, данные UTF-8 можно сохранить в
        базе данных MySQL под названием кодирования <code class="kw" translate="no">latin1</code>, ранее MySQL действительно поддерживала
        UTF-8, или Японские данные можно отметить <code class="kw" translate="no">sjis</code> в то время, когда в действительности они
        используют Shift-JIS версию Windows, которую MySQL называет <code class="kw" translate="no">cp932</code> (смотрите <a

class="print" href="http://dev.mysql.com/doc/refman/4.1/en/charset-cp932.html">The cp932
        Character Set</a> для получения дополнительной информации по этому поводу). В таких случаях столбик
        можно перемаркировать без преобразования путем изменения его типа на двоичный
        эквивалент (<code class="kw" translate="no">BINARY</code>, <code
class="kw" translate="no">VARBINARY</code>, <code class="kw" translate="no">BLOB</code>), затем вернуться обратно к
        символам (<code class="kw" translate="no">CHAR</code>, <code class="kw" translate="no">VARCHAR</code>, <code class="kw" translate="no">TEXT</code>) с правильным названием кодирования, например, для <code class="kw" translate="no">TEXT</code> столбика: <code>ALTER TABLE table CHANGE
        column column BLOB; ALTER TABLE table CHANGE column column TEXT
        CHARACTER SET utf8 COLLATION collation;</code>. Вы можете и должны изменить
        вместе все столбцы одной таблицы для того, чтобы свести к минимуму затраты на
        перестройку таблицы.</p>
      <div class="sideinfonote"><p class="warning">Примечание: PHP клиент для MySQL по умолчанию указывает <strong>latin1</strong> как кодирование для каждого нового соединения, поэтому необходимо
        вставить заявление <code>SET NAMES 'utf8'</code> для каждого нового соединения.</p></div>
    </div>
  </section>
  <section>
    <h3 id="filenames"><a href="#filenames">Преобразование имен
      файлов</a></h3>
    <p>Несколько серверных операционных систем (например, !FreeBSD, Red Hat) сохраняют
      имена файлов, как простые последовательности байтов, которые толкуются как
      процессы высшего уровня. Серверные процессы могут интерпретировать последовательности байтов соответственно
      к кодировке символов локали в которой они выполняются, или просто передать их
      клиентским процессам. Поэтому фактическое кодирование нужно определить
      путем оценки того, как было создано название, что для отдельного сайта или пользователя может быть через
      веб страницу в кодировке по умолчанию. Если это вас не убедит,
      то используйте обнаружение кодирования.</p>
    <p>Если точно можно определить кодировку имени файла, то его можно 
      преобразовать в UTF-8, и Byte Order Mark можно использовать, чтобы отметить его как 
      преобразованный. Если кодирование не определено, возможно понадобится создать 
      базу данных параллельно к файловой системе для записи обнаруженного кодирования и, 
      возможно, UTF-8 версии, так что оригинальное имя файла может храниться неподалеку 
      для дальнейшего исправления кодировки.</p>
  </section>
</section>
<section>
  <h2 id="testing"><a href="#testing">Тестирование с помощью Unicode</a></h2>
  <p>Не имеет смысла тестировать Unicode поддержку с ASCII текстом. Убедитесь, что вы
    проверяете обработку данных пользователя с текстом на разных языках, которые вы будете
    поддерживать:</p>
  <ul>
    <li>Латинские символы отличные от ASCII: <span lang="fr">élève</span>, <span lang="de">süß</span>, <span lang="tr">İstanbul</span>, <span lang="da">Århus</span>,
      ©®€“”’«»</li>
    <li>Восточноевропейские системы письма: <span lang="el">ελληνικά</span>, <span lang="ru">русский</span></li>
    <li>Восточно-Азиатские языки: <span lang="zh-hans">中文</span>, <span lang="ja">日本語</span>, <span lang="ko">한국어</span></li>
    <li>Юго-Восточные Азиатские языки: <span lang="vi">Tiếng Việt</span>, <span lang="th">ไทย</span></li>
    <li style="text-align: left;">Индийские языки: <span lang="hi">हिंदी</span></li>
  </ul>
  <p>Тестирование с этими языками требует, чтобы компьютер был настроен
    для их поддержки. <a
class="print" href="http://www.inter-locale.com/whitepaper/learn/learn_to_type.html">Учимся
    Печатать на Японском и Других Языках</a> содержит информацию о том, как это сделать
    для всех распространенных операционных систем.</p>
  <p>Чтобы показать, что текст в пользовательском интерфейсе вашей программы обрабатывается
    правильно, полезной будет такая стратегия тестирования, как псевдо-локализация.
    Инструменты псевдо-перевода могут автоматически заменять ASCII символы на
    сообщение пользовательского интерфейса с эквивалентными латинскими символами на всю ширину с
    Unicode диапазона от U+FF01 до U+FF5E (English -&gt; Ｅｎｇｌｉｓｈ) или с
    другими буквами с диакритическими знаками из полного Латинского диапазона (English
    -&gt; Ëñgłíšh).</p>
  <p>Вопросы, требующие особого внимания при тестировании поддержки 
    Unicode:</p>
  <ul>
    <li>Сохранение введенного пользователем текста на всем пути от ввода на
      клавиатуре с помощью программ и базы данных до повторного отображения.</li>
    <li>Везде правильная спецификация кодировок символов.</li>
    <li>Обнаружение устаревших кодировок, а также коррекция неправильно определенных
      кодировок.</li>
    <li>Преобразования в другие форматы, например, от формы ввода к RSS каналу.</li>
    <li>Поиск текста, в частности, поиски, которые не просто сравнивают последовательности
      байтов, например, поиск без учета регистра или поиск "похожего" текста, в том числе
      включая ввод данных в различных формах нормализации.</li>
    <li>Сортировка строк, включая строки в различных формах
      нормализации.</li>
  </ul>
  <p>Некоторые руководящие принципы для тестирования Unicode поддержки и интернационализации
    можно найти на: <a
class="print" href="http://www.inter-locale.com/whitepaper/learn/learn-to-test.html">Международные Основы
    Тестирования</a></p>
</section>
<section>
<h2 id="endlinks"><a href="#endlinks">Further reading</a></h2>
<aside class="section" id="survey"> </aside><script>document.getElementById('survey').innerHTML = g.survey</script>

  <ul id="full-links">
    <li>
      <p><a
    href="http://dev.mysql.com/doc/refman/4.1/en/charset.html">Поддержка Character 
        Set</a> для MySQL.</p>
    </li>
    <li>
      <p><a
    href="http://www.inter-locale.com/whitepaper/learn/learn_to_type.html">Учимся
        Печатать на Японском и Других Языках</a> содержит информацию о настройке
        и использовании всех распространенных операционных систем для многоязычного тестирования.</p>
    </li>
  </ul>
</section>

<footer id="thefooter"></footer><script type="text/javascript">document.getElementById('thefooter').innerHTML = g.bottomOfPage</script>
<script type="text/javascript">completePage()</script>
</body>
</html>
